<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>株式シグナルチェッカー (トレンド表示/確率分析/ニュース)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* フォント設定 */
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-osx-smoothing: grayscale;
        }

        /* カスタムローダー */
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spinner 2.5s linear infinite;
            animation: spinner 2.5s linear infinite;
        }

        @-webkit-keyframes spinner {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }

        @keyframes spinner {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* モーダルの背景 */
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.7);
        }
        /* 確率コンテナの最小幅を確保 */
        .prob-container {
            min-width: 160px;
        }
        /* シグナル根拠チェックマーク */
        .check-green {
            color: #10B981; /* Tailwind green-500 */
        }
        .check-red {
            color: #EF4444; /* Tailwind red-500 */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-900 min-h-screen">

    <!-- ヘッダー -->
    <header class="bg-white shadow-md top-0 left-0 right-0 z-10">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
            <h1 class="text-2xl font-bold text-gray-900">
                株式シグナルチェッカー (トレンド/確率分析/ニュース)
            </h1>
            <p class="mt-1 text-sm text-gray-500">MACD、トレンド(5/25MA)、確率分析を自動監視します (3秒ごとに自動更新)。ニュース検索は手動です。</p>
        </div>
    </header>

    <!-- メインコンテンツ -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">

        <!-- 銘柄追加フォーム -->
        <div class="bg-white p-6 rounded-lg shadow-lg mb-8">
            <h2 class="text-xl font-semibold mb-4">監視銘柄の追加</h2>
            <form id="add-stock-form" class="grid grid-cols-1 md:grid-cols-12 gap-4 items-end">
                <div class="md:col-span-2">
                    <label for="market-select" class="block text-sm font-medium text-gray-700">市場</label>
                    <select id="market-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm h-12">
                        <option value="US">米国株 (例: AAPL)</option>
                        <option value="JP">日本株 (例: 7203)</option>
                    </select>
                </div>
                <div class="md:col-span-6">
                    <label for="symbol-input" class="block text-sm font-medium text-gray-700">銘柄コード (シンボル)</label>
                    <input type="text" id="symbol-input" placeholder="AAPL" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm h-12" required>
                </div>
                <div class="md:col-span-4">
                    <button type="submit" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out w-full whitespace-nowrap">
                        追加して監視開始
                    </button>
                </div>
            </form>
            <p id="form-error" class="text-red-500 text-sm mt-2"></p>
        </div>
        
        <!-- シグナル銘柄一覧エリア (新規追加) -->
        <div id="signal-summary-area" class="bg-indigo-100 p-4 rounded-lg shadow-md mb-8 hidden">
            <h2 class="text-xl font-semibold text-indigo-800 mb-3 flex items-center">
                <svg class="w-6 h-6 mr-2 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                発生中のシグナル (短期/日足)
            </h2>
            <div id="signal-summary-list" class="flex flex-wrap gap-3">
                <!-- シグナル銘柄がここに挿入されます -->
                <p class="text-indigo-600 text-sm">現在、新規エントリーシグナルが出ている銘柄はありません。</p>
            </div>
        </div>

        <!-- 監視中リスト -->
        <div>
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold">監視中リスト</h2>
            </div>
            <!-- カードを大きくするため、デスクトップでの列数を2列に変更 -->
            <div id="watchlist" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- 監視中銘柄カードがここに挿入されます -->
                <p class="text-gray-500 col-span-full">監視中の銘柄はありません。</p>
            </div>
        </div>

    </main>

    <!-- フッター -->
    <footer class="bg-white mt-12 border-t border-gray-200">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 text-center text-sm text-gray-500">
            <p>データ提供: <a href="https://finance.yahoo.com/" target="_blank" rel="noopener" class="text-indigo-600 hover:underline">Yahoo Finance</a> (via corsproxy.io)</p>
            <p class="mt-1">免責事項: このツールは情報提供のみを目的としており、投資助言ではありません。取引はご自身の責任において行ってください。</p>
        </div>
    </footer>
    
    <!-- ニュース表示用モーダル (リストの邪魔にならない独立した要素) -->
    <div id="news-modal" class="fixed inset-0 z-50 hidden items-center justify-center modal-overlay">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl mx-4 my-8 p-6 transform transition-all overflow-y-auto max-h-[90vh]">
            <div class="flex justify-between items-start border-b pb-3 mb-4">
                <h3 class="text-xl font-bold text-gray-900" id="modal-title">ニュース検索結果</h3>
                <button id="close-modal" class="text-gray-400 hover:text-gray-700 transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            
            <!-- ニュースコンテンツエリア -->
            <div id="modal-news-content" class="min-h-[100px] text-gray-800">
                <!-- 検索中または結果がここに挿入されます -->
            </div>
            
            <!-- 引用元エリア -->
            <div id="modal-news-sources" class="mt-6 pt-4 border-t border-gray-200">
                <p class="text-sm font-semibold text-gray-700 mb-2">引用元情報:</p>
                <div id="modal-source-links" class="text-xs text-gray-500 space-y-2">
                    <!-- ソースリンクがここに挿入されます -->
                </div>
            </div>
        </div>
    </div>


    <!-- JSロジック -->
    <script type="module">
        document.addEventListener('DOMContentLoaded', () => {
            // --- 設定 ---
            const STORAGE_KEY = 'stockSignalWatchlist_v2'; 
            const UPDATE_INTERVAL = 3000; 
            const REFRESH_RATE = 100; 
            const ENTRY_STRENGTH_THRESHOLD = 3; 

            // 短期変動分析用の期間 (10分間のシミュレーション)
            const SHORT_TERM_PERIOD_MS = 10 * 60 * 1000; 
            // 短期変動の判定に必要な変動率
            const SHORT_TERM_CHANGE_THRESHOLD = 0.005; // 0.5%以上の変動で急変動と判定

            // --- DOM要素 ---
            const addStockForm = document.getElementById('add-stock-form');
            const marketSelect = document.getElementById('market-select');
            const symbolInput = document.getElementById('symbol-input');
            const formError = document.getElementById('form-error');
            const watchlistContainer = document.getElementById('watchlist');
            const newsModal = document.getElementById('news-modal');
            const closeModalButton = document.getElementById('close-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalNewsContent = document.getElementById('modal-news-content');
            const modalSourceLinks = document.getElementById('modal-source-links');
            const signalSummaryArea = document.getElementById('signal-summary-area');
            const signalSummaryList = document.getElementById('signal-summary-list');

            // --- アプリケーション状態 ---
            let watchlist = []; 

            // 銘柄ごとの短期価格履歴
            let shortTermPriceHistory = {}; 
            
            // --- APIヘルパー (Yahoo Finance) ---
            async function fetchApi(symbol, interval = '1d') {
                const range = (interval === '1d') ? '2y' : '1d'; // 日足は2年、短期は1日
                const targetUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?range=${range}&interval=${interval}`;
                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                
                try {
                    const response = await fetch(proxyUrl);
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            throw new Error(`銘柄コード '${symbol}' が見つかりません (404)`);
                        }
                        throw new Error(`HTTP error! (Proxy or Target) status: ${response.status}`);
                    }
                    
                    const data = await response.json(); 
                    
                    if (data.chart.error) {
                        throw new Error(`Yahoo Finance APIエラー: ${data.chart.error.description || data.chart.error.code}`);
                    }
                    
                    if (!data.chart.result || !data.chart.result[0] || !data.chart.result[0].indicators.quote[0]) {
                         // 短期データ取得時はデータが空の場合があるため、ここでは致命的なエラーとしない
                         if (interval === '1d') {
                             throw new Error("Yahoo Financeから有効な日足データが返されませんでした。銘柄コードが間違っている可能性があります。");
                         }
                         return { chart: { result: [null] } };
                    }
                    
                    return data;

                } catch (error) {
                    console.error(`Fetch error for ${proxyUrl}:`, error);
                    if (error.message.includes('Failed to fetch')) {
                        throw new Error("ネットワークエラー。Yahoo Finance API(プロキシ経由)へのアクセスに失敗しました。");
                    }
                    throw error;
                }
            }

            /**
             * 短期変動シグナルと数値、支持抵抗ラインを計算
             * @returns {object} 短期シグナルと変動率、支持抵抗ライン
             */
            function checkShortTermSignal(stockId, currentPrice) {
                const defaultResult = { text: '安定', icon: '〰', color: 'text-gray-500', change: '0.00%', changeValue: 0, high: null, low: null };

                if (typeof currentPrice !== 'number' || currentPrice <= 0) {
                    return defaultResult;
                }

                // 履歴を更新
                const now = Date.now();
                if (!shortTermPriceHistory[stockId]) {
                    shortTermPriceHistory[stockId] = [];
                }
                // 最新の価格とタイムスタンプを追加
                shortTermPriceHistory[stockId].push({ time: now, price: currentPrice });

                // 10分以内のデータのみに絞り込む
                const cutoffTime = now - SHORT_TERM_PERIOD_MS;
                shortTermPriceHistory[stockId] = shortTermPriceHistory[stockId].filter(
                    data => data.time >= cutoffTime
                );

                const history = shortTermPriceHistory[stockId];
                
                if (history.length < 2) {
                    return defaultResult;
                }

                // 10分間の最高値 (短期抵抗) と最安値 (短期支持) を検索
                let highest = -Infinity;
                let lowest = Infinity;
                
                history.forEach(data => {
                    if (data.price > highest) highest = data.price;
                    if (data.price < lowest) lowest = data.price;
                });
                
                // 変動率を計算
                let startPrice = history[0].price;
                const changeValue = (currentPrice - startPrice) / startPrice;
                const changePercent = (changeValue * 100).toFixed(2);

                const upChange = (currentPrice - lowest) / lowest;
                const downChange = (highest - currentPrice) / highest;
                
                let result = defaultResult;
                
                if (upChange >= SHORT_TERM_CHANGE_THRESHOLD && downChange < SHORT_TERM_CHANGE_THRESHOLD) {
                    result = { text: '急上昇中', icon: '▲', color: 'text-green-500' };
                } else if (downChange >= SHORT_TERM_CHANGE_THRESHOLD && upChange < SHORT_TERM_CHANGE_THRESHOLD) {
                    result = { text: '急下降中', icon: '▼', color: 'text-red-500' };
                } else if (highest > 0 && (highest - lowest) / highest > SHORT_TERM_CHANGE_THRESHOLD * 2) {
                     result = { text: '激しい変動', icon: '↯', color: 'text-orange-500' };
                } else {
                    result = { text: '安定', icon: '〰', color: 'text-gray-500' };
                }
                
                result.change = (changeValue > 0 ? '+' : '') + changePercent + '%';
                result.changeValue = changeValue;
                result.high = highest; // 短期抵抗ライン
                result.low = lowest;   // 短期支持ライン
                
                return result;
            }


            // --- テクニカル指標計算ヘルパー (変更なし) ---
            /** SMA (単一値) */
            function calculateSMA(data, period) {
                if (!data) return null;
                const validData = [];
                for (let i = 0; i < data.length; i++) {
                    if (typeof data[i] === 'number') {
                        validData.push(data[i]);
                        if (validData.length >= period) break;
                    }
                }
                if (validData.length < period) return null; 
                const sum = validData.reduce((acc, val) => acc + val, 0);
                return sum / period;
            }

            /** SMA (配列) */
            function calculateSMAArray(data, period) {
                if (!data || data.length < period) return new Array(data.length).fill(null);
                let smaArray = new Array(data.length).fill(null);
                for (let i = period - 1; i < data.length; i++) {
                    let sum = 0;
                    let count = 0;
                    let hasNull = false;
                    for (let j = 0; j < period; j++) {
                        if (typeof data[i - j] === 'number') {
                            sum += data[i - j];
                            count++;
                        } else {
                            hasNull = true;
                            break; 
                        }
                    }
                    if (!hasNull && count === period) {
                        smaArray[i] = sum / period;
                    }
                }
                return smaArray;
            }

            /** EMA (配列) */
            function calculateEMA(data, period) {
                if (!data || data.length < period) return [];
                let k = 2 / (period + 1);
                let emaArray = new Array(data.length).fill(null);
                let initialData = [];
                let firstSmaIndex = -1; 
                for (let i = 0; i < data.length; i++) {
                    if (typeof data[i] === 'number') {
                        initialData.push(data[i]);
                        if (initialData.length === period) {
                            firstSmaIndex = i;
                            break;
                        }
                    }
                }
                if (firstSmaIndex === -1) return [];
                let sum = initialData.reduce((acc, val) => acc + val, 0);
                emaArray[firstSmaIndex] = sum / period;
                for (let i = firstSmaIndex + 1; i < data.length; i++) {
                    const currentVal = data[i];
                    const prevEma = emaArray[i - 1];
                    if (typeof currentVal === 'number' && typeof prevEma === 'number') {
                        emaArray[i] = (currentVal * k) + (prevEma * (1 - k));
                    } else if (typeof prevEma === 'number') {
                        emaArray[i] = prevEma;
                    }
                }
                return emaArray;
            }
            
            /** MACD */
            function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
                if (prices.length < slowPeriod + signalPeriod) return null;
                const emaFast = calculateEMA(prices, fastPeriod); 
                const emaSlow = calculateEMA(prices, slowPeriod);
                let macdLineRaw = [];
                let validMacdPoints = [];
                for (let i = 0; i < prices.length; i++) {
                    if (typeof emaFast[i] === 'number' && typeof emaSlow[i] === 'number') {
                        const macdVal = emaFast[i] - emaSlow[i];
                        macdLineRaw[i] = macdVal;
                        validMacdPoints.push(macdVal);
                    } else {
                        macdLineRaw[i] = null;
                    }
                }
                if (validMacdPoints.length < signalPeriod + 2) return null; 
                const signalLineValid = calculateEMA(validMacdPoints, signalPeriod); 
                let signalLine = new Array(prices.length).fill(null);
                let histLine = new Array(prices.length).fill(null); 
                let validIndex = 0;
                for (let i = 0; i < prices.length; i++) {
                    if (typeof macdLineRaw[i] === 'number') {
                         if (typeof signalLineValid[validIndex] === 'number') { 
                             const signalVal = signalLineValid[validIndex];
                             signalLine[i] = signalVal;
                             histLine[i] = macdLineRaw[i] - signalVal; 
                         }
                         validIndex++;
                    }
                }
                let todayData = null;
                let yesterdayData = null;
                for (let i = prices.length - 1; i >= 1; i--) {
                    const macd_i = macdLineRaw[i];
                    const signal_i = signalLine[i];
                    const hist_i = histLine[i]; 
                    if (typeof macd_i === 'number' && typeof signal_i === 'number' && typeof hist_i === 'number') {
                        if (todayData === null) {
                            todayData = { macd: macd_i, signal: signal_i, hist: hist_i }; 
                        } else if (yesterdayData === null) {
                            yesterdayData = { macd: macd_i, signal: signal_i }; 
                            break;
                        }
                    }
                }
                if (todayData === null || yesterdayData === null) {
                    return null;
                }
                return {
                    today: todayData,
                    yesterday: yesterdayData,
                    histArray: histLine 
                };
            }

            /** RSI (配列) */
            function calculateRSIArray(prices, period = 14) {
                if (prices.length <= period) return new Array(prices.length).fill(null);
                let rsiArray = new Array(prices.length).fill(null);
                let changes = [];
                for (let i = 1; i < prices.length; i++) {
                    if (typeof prices[i] === 'number' && typeof prices[i - 1] === 'number') {
                        changes[i] = prices[i] - prices[i - 1];
                    } else {
                        changes[i] = 0; 
                    }
                }
                let gains = 0;
                let losses = 0;
                let firstAvgIndex = -1;
                for (let i = 1; i <= period; i++) {
                     if (i >= changes.length) break;
                     const change = changes[i];
                     if (change > 0) {
                        gains += change;
                     } else {
                        losses -= change;
                     }
                     if (i === period) {
                         firstAvgIndex = period;
                     }
                }
                if (firstAvgIndex === -1) return rsiArray;
                let avgGain = gains / period;
                let avgLoss = losses / period;
                if (avgLoss === 0) {
                     rsiArray[firstAvgIndex] = 100;
                } else {
                     let rs = avgGain / avgLoss;
                     rsiArray[firstAvgIndex] = 100 - (100 / (1 + rs));
                }
                for (let i = firstAvgIndex + 1; i < prices.length; i++) {
                    if (i >= changes.length) break;
                    const change = changes[i];
                    let gain = change > 0 ? change : 0;
                    let loss = change < 0 ? -change : 0;
                    avgGain = (avgGain * (period - 1) + gain) / period;
                    avgLoss = (avgLoss * (period - 1) + loss) / period;
                    if (avgLoss === 0) {
                        rsiArray[i] = 100;
                    } else {
                        let rs = avgGain / avgLoss;
                        rsiArray[i] = 100 - (100 / (1 + rs));
                    }
                }
                return rsiArray;
            }

            /** ATR */
            function calculateATR(dailyDataArray, period = 14) {
                if (dailyDataArray.length <= period) return null;
                let trValues = [];
                let prevClose = null;
                for (let i = 0; i < dailyDataArray.length; i++) {
                    const data = dailyDataArray[i];
                    if (typeof data.high !== 'number' || typeof data.low !== 'number' || typeof data.close !== 'number') {
                        prevClose = (typeof data.close === 'number') ? data.close : prevClose;
                        continue;
                    }
                    if (prevClose === null) {
                        prevClose = data.close;
                        continue;
                    }
                    const tr1 = data.high - data.low;
                    const tr2 = Math.abs(data.high - prevClose);
                    const tr3 = Math.abs(data.low - prevClose);
                    trValues.push(Math.max(tr1, tr2, tr3));
                    prevClose = data.close;
                }
                if (trValues.length < period) return null;
                let relevantTrs = trValues.slice(trValues.length - period * 2);
                if (relevantTrs.length < period) relevantTrs = trValues;
                if (relevantTrs.length < period) return null;
                let atrSum = 0;
                for (let i = 0; i < period; i++) {
                    atrSum += relevantTrs[i];
                }
                let atr = atrSum / period;
                for (let i = period; i < relevantTrs.length; i++) {
                    atr = (atr * (period - 1) + relevantTrs[i]) / period;
                }
                return atr;
            }
            
            /** 平滑化移動平均 (SMMA) */
            function calculateSMMA(data, period) {
                if (data.length < period) return [];
                let smmaArray = new Array(data.length).fill(null);
                let sum = 0;
                for (let i = 0; i < period; i++) {
                    sum += data[i];
                }
                smmaArray[period - 1] = sum / period;
                for (let i = period; i < data.length; i++) {
                    smmaArray[i] = (smmaArray[i - 1] * (period - 1) + data[i]) / period;
                }
                return smmaArray;
            }

            /** ADX (平均方向性指数) */
            function calculateADX(dailyDataArray, period = 14) {
                if (dailyDataArray.length <= (period * 2)) return null; 
                let trValues = [];
                let plusDMValues = [];
                let minusDMValues = [];
                let prevClose = null;
                let prevHigh = null;
                let prevLow = null;
                for (let i = 0; i < dailyDataArray.length; i++) {
                    const data = dailyDataArray[i];
                    if (typeof data.high !== 'number' || typeof data.low !== 'number' || typeof data.close !== 'number') {
                        prevClose = (typeof data.close === 'number') ? data.close : prevClose;
                        prevHigh = (typeof data.high === 'number') ? data.high : prevHigh;
                        prevLow = (typeof data.low === 'number') ? data.low : prevLow;
                        continue;
                    }
                    if (prevClose === null || prevHigh === null || prevLow === null) {
                        prevClose = data.close;
                        prevHigh = data.high;
                        prevLow = data.low;
                        continue;
                    }
                    const tr1 = data.high - data.low;
                    const tr2 = Math.abs(data.high - prevClose);
                    const tr3 = Math.abs(data.low - prevClose);
                    const tr = Math.max(tr1, tr2, tr3);
                    trValues.push(tr);
                    const upMove = data.high - prevHigh;
                    const downMove = prevLow - data.low;
                    let plusDM = 0;
                    let minusDM = 0;
                    if (upMove > downMove && upMove > 0) {
                        plusDM = upMove;
                    }
                    if (downMove > upMove && downMove > 0) {
                        minusDM = downMove;
                    }
                    plusDMValues.push(plusDM);
                    minusDMValues.push(minusDM);
                    prevClose = data.close;
                    prevHigh = data.high;
                    prevLow = data.low;
                }
                const validTR = trValues.slice(1).filter(v => typeof v === 'number');
                const validPlusDM = plusDMValues.slice(1).filter(v => typeof v === 'number');
                const validMinusDM = minusDMValues.slice(1).filter(v => typeof v === 'number');
                if (validTR.length < period || validPlusDM.length < period || validMinusDM.length < period) return null;
                const smmaTR = calculateSMMA(validTR, period);
                const smmaPlusDM = calculateSMMA(validPlusDM, period);
                const smmaMinusDM = calculateSMMA(validMinusDM, period);
                let dxValues = [];
                for (let i = period - 1; i < smmaTR.length; i++) {
                    const atr = smmaTR[i];
                    if (atr === null || atr === 0) continue;
                    const pDI = (smmaPlusDM[i] / atr) * 100;
                    const mDI = (smmaMinusDM[i] / atr) * 100;
                    const diSum = pDI + mDI;
                    if (diSum > 0) {
                        const dx = (Math.abs(pDI - mDI) / diSum) * 100;
                        dxValues.push(dx);
                    }
                }
                const validDx = dxValues.filter(v => typeof v === 'number');
                if (validDx.length < period) return null; 
                const adxLine = calculateSMMA(validDx, period);
                const lastAdx = adxLine.pop();
                return (typeof lastAdx === 'number') ? lastAdx : null;
            }

            /** ボリンジャーバンド (バンド幅比較用) */
            function calculateBollingerBands(prices, period = 20, stdDevMultiplier = 2) {
                if (prices.length < period + 5) return null; 
                const smaArray = calculateSMAArray(prices, period);
                let bandwidthArray = [];
                for (let i = period - 1; i < prices.length; i++) {
                    if (smaArray[i] === null) {
                        bandwidthArray.push(null);
                        continue;
                    }
                    const middle = smaArray[i];
                    let sumStdDev = 0;
                    let count = 0;
                    for (let j = 0; j < period; j++) {
                        if (typeof prices[i - j] === 'number') {
                            sumStdDev += Math.pow(prices[i - j] - middle, 2);
                            count++;
                        }
                    }
                    if (count < period) {
                         bandwidthArray.push(null);
                         continue;
                    }
                    const stdDev = Math.sqrt(sumStdDev / period);
                    const upper = middle + (stdDev * stdDevMultiplier);
                    const lower = middle - (stdDev * stdDevMultiplier);
                    if (middle > 0) {
                        const bandwidth = (upper - lower) / middle;
                        bandwidthArray.push(bandwidth);
                    } else {
                        bandwidthArray.push(null);
                    }
                }
                const validBandwidths = bandwidthArray.filter(v => typeof v === 'number');
                if (validBandwidths.length < 6) return null; 
                const bandwidth_today = validBandwidths[validBandwidths.length - 1];
                const bandwidth_5days_ago = validBandwidths[validBandwidths.length - 6]; 
                if (typeof bandwidth_today === 'number' && typeof bandwidth_5days_ago === 'number') {
                    return { bandwidth: bandwidth_today, bandwidth_5days_ago: bandwidth_5days_ago };
                }
                return null;
            }

            /** 出来高フォーマット */
            function formatVolume(num) {
                if (typeof num !== 'number' || num === null || num === 0) return '--';
                if (num >= 1000000) {
                    return (num / 1000000).toFixed(1) + 'M';
                }
                if (num >= 1000) {
                    return Math.round(num / 1000).toFixed(0) + 'K'; 
                }
                return num.toString();
            }

            /** ピボットポイント */
            function calculatePivotPoints(dailyDataArray) {
                let yesterday = null;
                let validCount = 0;
                for (let i = dailyDataArray.length - 1; i >= 0; i--) {
                    const data = dailyDataArray[i];
                    if (data && typeof data.high === 'number' && typeof data.low === 'number' && typeof data.close === 'number') {
                        validCount++;
                        if (validCount === 2) { 
                            yesterday = data;
                            break;
                        }
                    }
                }
                if (yesterday === null) return null; 
                const h = yesterday.high;
                const l = yesterday.low;
                const c = yesterday.close;
                const p = (h + l + c) / 3;
                const r1 = (2 * p) - l;
                const s1 = (2 * p) - h;
                return { p: p, r1: r1, s1: s1 };
            }

            /** 直近N日間の最高値 */
            function calculateHighestHigh(prices, period) {
                if (!prices || prices.length < period) return null;
                let highest = 0;
                let foundValid = false;
                for (let i = prices.length - 1; i >= prices.length - period; i--) {
                    if (i < 0) break;
                    const price = prices[i];
                    if (typeof price === 'number') {
                        if (!foundValid || price > highest) {
                            highest = price;
                        }
                        foundValid = true;
                    }
                }
                return foundValid ? highest : null;
            }

            /** 利益/損失確率 (簡易バックテスト) */
            function calculateProbabilities(prices, signalIndex, periodDays) {
                if (prices.length === 0 || typeof prices[prices.length - 1] !== 'number') {
                    return { winRate: null, lossRate: null, period: periodDays, total: 0 };
                }

                let results = { win: 0, loss: 0, neutral: 0, total: 0 };
                const maxSimulatableIndex = prices.length - 1 - periodDays;
                
                if (maxSimulatableIndex < 0) {
                    return { winRate: 0, lossRate: 0, period: periodDays, total: 0 };
                }
                const startIndex = 0; 

                for (let i = startIndex; i <= maxSimulatableIndex; i++) {
                    
                    const startPrice = prices[i];
                    if (typeof startPrice !== 'number') continue;
                    
                    let endPrice = null;
                    let targetIndex = i + periodDays;

                    for (let j = 0; j <= 5; j++) { 
                        let currentTargetIndex = targetIndex + j;
                        if (currentTargetIndex < prices.length && typeof prices[currentTargetIndex] === 'number') {
                            endPrice = prices[currentTargetIndex];
                            break;
                        }
                    }

                    if (endPrice !== null && typeof endPrice === 'number' && startPrice !== 0) { 
                        results.total++;
                        const change = (endPrice - startPrice) / startPrice;
                        
                        if (change > 0.005) {
                            results.win++;
                        } else if (change < -0.005) {
                            results.loss++;
                        } else {
                            results.neutral++;
                        }
                    }
                }
                
                if (results.total === 0) return { winRate: 0, lossRate: 0, period: periodDays, total: 0 };

                const winRate = (results.win / results.total) * 100;
                const lossRate = (results.loss / results.total) * 100;
                
                return { winRate: winRate, lossRate: lossRate, period: periodDays, total: results.total };
            }
            
            // --- APIヘルパー (Gemini) ---
            const apiKey = ""; 
            const GEMINI_MODEL = 'gemini-2.5-flash-preview-09-2025';
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;

            async function fetchGeminiNews(symbol) {
                const systemPrompt = `あなたは世界経済と金融市場に精通した日本語のAIアシスタントです。Google Search Toolを使用して、過去48時間以内に発生した ${symbol} 株に関連する最新のニュースやイベントを検索し、その株価への影響について簡潔に、しかし専門的に分析した単一の段落の要約を作成してください。要約は日本語で記述し、専門用語は分かりやすく説明してください。`;
                const userQuery = `${symbol} の最近のニュースと株価への影響について、最新の情報を基に分析を要約してください。`;
                
                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    tools: [{ "google_search": {} }],
                    systemInstruction: {
                        parts: [{ text: systemPrompt }]
                    },
                };

                let retries = 0;
                let maxRetries = 3;
                let delay = 1000; 

                while (retries < maxRetries) {
                    try {
                        const response = await fetch(API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            if (response.status === 429 && retries < maxRetries - 1) {
                                retries++;
                                delay *= 2; 
                                await new Promise(resolve => setTimeout(resolve, delay));
                                continue;
                            }
                            throw new Error(`APIリクエストエラー: ${response.status} ${response.statusText}`);
                        }

                        const result = await response.json();
                        const candidate = result.candidates?.[0];

                        if (!candidate || !candidate.content?.parts?.[0]?.text) {
                            throw new Error("Geminiから有効な応答がありませんでした。");
                        }
                        
                        const text = candidate.content.parts[0].text;
                        let sources = [];
                        const groundingMetadata = candidate.groundingMetadata;
                        
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            sources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title,
                                }))
                                .filter(source => source.uri && source.title); 
                        }

                        return { text, sources };

                    } catch (error) {
                        console.error(`Gemini API Fetch Error (Attempt ${retries + 1}):`, error);
                        if (retries < maxRetries - 1) {
                            retries++;
                            delay *= 2; 
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        throw new Error(`ニュース検索に失敗しました: ${error.message}`);
                    }
                }
                throw new Error("ニュース検索に失敗しました: リトライ回数を超過しました。");
            }


            /**
             * 銘柄カードごとの自動更新タイマーとプログレスバーを開始する
             */
            function startStockTimer(stock) {
                if (stock.timerId) {
                    clearInterval(stock.timerId);
                }

                let progress = 0;
                const card = document.getElementById(`card-${stock.id}`);
                const progressBar = card ? card.querySelector('[data-status="progress-bar"]') : null;
                
                if (!progressBar) return; 

                const increment = 100 / (UPDATE_INTERVAL / REFRESH_RATE);
                
                progressBar.style.transition = 'none';
                progressBar.style.width = '0%';
                
                requestAnimationFrame(() => {
                    progressBar.style.transition = `width ${REFRESH_RATE / 1000}s linear`;
                });

                stock.timerId = setInterval(() => {
                    progress += increment;

                    if (progress >= 100) {
                        progress = 0; 
                        checkStockSignal(stock); 
                        
                        progressBar.style.transition = 'none';
                        progressBar.style.width = '0%';

                        requestAnimationFrame(() => {
                            progressBar.style.transition = `width ${REFRESH_RATE / 1000}s linear`;
                        });
                        
                    } else {
                         progressBar.style.width = `${progress}%`;
                    }
                }, REFRESH_RATE);
            }


            // --- コアロジック: シグナル判定 ---
            async function checkStockSignal(stock) {
                const card = document.getElementById(`card-${stock.id}`);
                const priceText = card ? card.querySelector('[data-status="price"]') : null;
                const currentPrice = (priceText && priceText.textContent !== '--.--') ? parseFloat(priceText.textContent) : NaN;
                
                const stockInWatchlist = watchlist.find(s => s.id === stock.id);
                if (!stockInWatchlist) return; 
                
                const dummyTrend = { text: '--', icon: '↔', color: 'text-gray-500', value: 0 };
                // 短期シグナルは常に最新のcurrentPriceでチェックする
                const shortTermSignal = checkShortTermSignal(stock.id, currentPrice);

                // ローディング表示を更新
                if (!stockInWatchlist.position) {
                     updateCardStatus(stock.id, 'loading', '', currentPrice, dummyTrend, shortTermSignal, 0, 0, 0, null, null, null, null, null, [], null, {}); 
                } else {
                     updateCardStatus(stock.id, 'loading', '', currentPrice, dummyTrend, shortTermSignal, 0, 0, 0, null, null, null, null, null, [], null, {});
                }

                let todayClose = currentPrice; // 更新がない場合は前回の価格を使用
                let trendSummary = dummyTrend;
                let dayHigh = null;
                let dayLow = null;
                let todayVolume = null;
                let momentum = { short: 'neutral', mid: 'neutral' };
                let pivots = null;
                let features = [];
                let signalDetails = {}; // 新規追加: シグナル根拠の詳細
                let probability = null;
                let macdResult = null;
                let atr_today = null;
                let highestHigh20 = null;
                let isShortSignalBase = false;
                let isLongSignalBase = false;
                let isBreakoutSignal = false;
                let rsi_today = null;
                let rsi_yesterday = null;
                let adx_today = null;
                let sma5 = null;
                let sma25 = null;
                let sma5_yesterday = null;
                let sma25_yesterday = null;
                let sma25_5days_ago = null;
                let bb_today = null;

                let dailyDataFetchError = false;

                try {
                    // --- 1. 日足データ取得と分析 ---
                    const dailyData = await fetchApi(stock.fullSymbol, '1d');

                    const result = dailyData.chart.result[0];
                    const indicators = result.indicators.quote[0];
                    const timestamps = result.timestamp;
                    
                    let chronoPrices = [];
                    let chronoDailyObjects = [];
                    let chronoVolumes = [];

                    for (let i = 0; i < timestamps.length; i++) {
                        const open = indicators.open[i]; 
                        const close = indicators.close[i];
                        const high = indicators.high[i];
                        const low = indicators.low[i];
                        const volume = indicators.volume[i];

                        chronoPrices.push(typeof close === 'number' ? close : null);
                        chronoVolumes.push(typeof volume === 'number' ? volume : null);
                        
                        chronoDailyObjects.push({
                            open: typeof open === 'number' ? open : null, 
                            high: typeof high === 'number' ? high : null,
                            low: typeof low === 'number' ? low : null,
                            close: typeof close === 'number' ? close : null
                        });
                    }

                    if (chronoPrices.length < 50) {
                        throw new Error(`分析に必要なデータ期間が不足しています ( ${chronoPrices.length} / 50 )。`);
                    }

                    let lastValidData = null;
                    let secondLastValidData = null;

                    for (let i = chronoPrices.length - 1; i >= 0; i--) {
                        if (typeof chronoPrices[i] === 'number' && typeof chronoVolumes[i] === 'number') {
                            const lastObject = chronoDailyObjects[i];
                            if (lastObject && typeof lastObject.high === 'number' && typeof lastObject.low === 'number') {
                                if (lastValidData === null) {
                                    lastValidData = {
                                        close: chronoPrices[i],
                                        volume: chronoVolumes[i],
                                        high: lastObject.high, 
                                        low: lastObject.low   
                                    };
                                } else if (secondLastValidData === null) {
                                     secondLastValidData = {
                                        close: chronoPrices[i],
                                        volume: chronoVolumes[i],
                                    };
                                    break;
                                }
                            }
                        }
                    }

                    if (lastValidData === null || secondLastValidData === null) {
                        throw new Error("有効な最新データが見つかりませんでした。");
                    }
                    
                    todayClose = lastValidData.close;
                    dayHigh = lastValidData.high; 
                    dayLow = lastValidData.low;   
                    todayVolume = lastValidData.volume;
                    
                    // --- テクニカル指標の計算 ---
                    macdResult = calculateMACD(chronoPrices);
                    const rsiArray = calculateRSIArray(chronoPrices); 
                    rsi_today = rsiArray.filter(v => typeof v === 'number').pop() || null; 
                    rsi_yesterday = rsiArray.filter(v => typeof v === 'number').slice(-2, -1)[0] || null;
                    atr_today = calculateATR(chronoDailyObjects);
                    adx_today = calculateADX(chronoDailyObjects); 
                    bb_today = calculateBollingerBands(chronoPrices); 
                    pivots = calculatePivotPoints(chronoDailyObjects); 
                    highestHigh20 = calculateHighestHigh(chronoPrices, 20); 

                    const volumes_desc = [...chronoVolumes].reverse();
                    const vma20 = calculateSMA(volumes_desc, 20);
                    const volumeRatio = (vma20 > 0 && todayVolume > 0) ? todayVolume / vma20 : 0;

                    const sma5Array = calculateSMAArray(chronoPrices, 5);
                    const sma25Array = calculateSMAArray(chronoPrices, 25);
                    
                    sma5 = sma5Array.filter(v => typeof v === 'number').pop();
                    sma5_yesterday = sma5Array.filter(v => typeof v === 'number').slice(-2, -1)[0] || null;
                    sma25 = sma25Array.filter(v => typeof v === 'number').pop();
                    sma25_yesterday = sma25Array.filter(v => typeof v === 'number').slice(-2, -1)[0] || null;
                    sma25_5days_ago = sma25Array.filter(v => typeof v === 'number').slice(-6, -5)[0] || null;

                    if (macdResult === null || rsi_today === null || atr_today === null || vma20 === null || adx_today === null || sma25_5days_ago === null || bb_today === null || pivots === null || highestHigh20 === null || sma5_yesterday === null || sma25_yesterday === null || rsi_yesterday === null) {
                        throw new Error("テクニカル指標の計算に失敗しました。データ不足の可能性があります。");
                    }
                    
                    // --- 日足トレンド判定の強化 (矢印と強弱) ---
                    const isSma5Up = sma5 > sma5_yesterday;
                    const isSma25Up = sma25 > sma25_yesterday;
                    
                    let trendText = ''; // テキストを削除
                    let trendIcon = '↔';
                    let trendColor = 'text-gray-500';
                    let trendValue = 0; 

                    if (typeof sma5 === 'number' && typeof sma25 === 'number' && sma25 !== 0) {
                        trendValue = ((sma5 - sma25) / sma25) * 100; // 乖離率 (%)
                        
                        if (sma5 > sma25) { 
                            if (isSma5Up && isSma25Up) {
                                trendIcon = '▲▲';
                                trendColor = 'text-green-600';
                            } else if (isSma5Up) {
                                trendIcon = '↑';
                                trendColor = 'text-green-500';
                            } else {
                                trendIcon = '▲';
                                trendColor = 'text-green-500/70'; 
                            }
                        } else if (sma5 < sma25) { 
                            if (!isSma5Up && !isSma25Up) {
                                trendIcon = '▼▼';
                                trendColor = 'text-red-600';
                            } else if (!isSma5Up) {
                                trendIcon = '↓';
                                trendColor = 'text-red-500';
                            } else {
                                trendIcon = '▼';
                                trendColor = 'text-red-500/70'; 
                            }
                        }
                    }
                    trendSummary = { text: trendText, icon: trendIcon, color: trendColor, value: trendValue };

                    // --- MACD, Volume, RSI判定 ---
                    const macd_today = macdResult.today.macd;
                    const signal_today = macdResult.today.signal;
                    const hist_today = macdResult.today.hist;
                    const macd_yesterday = macdResult.yesterday.macd;
                    const signal_yesterday = macdResult.yesterday.signal;
                    const macdCrossDistance = macd_today - signal_today; // クロス距離

                    const isLongCross = (macd_yesterday < signal_yesterday) && (macd_today > signal_today);
                    const isHistPositive = hist_today > 0;
                    const isShortCross = (macd_yesterday > signal_yesterday) && (macd_today < signal_yesterday); 
                    const isHistNegative = hist_today < 0;
                    const isRsiInRange = (rsi_today !== null) && rsi_today > 35 && rsi_today < 70;
                    const isVolumeHigh_1_5 = todayVolume > (vma20 * 1.5);
                    const isVolumeHigh_2_0 = todayVolume > (vma20 * 2.0);

                    isLongSignalBase = isLongCross && isHistPositive;
                    isShortSignalBase = isShortCross && isHistNegative;
                    const isR1Break = todayClose > pivots.r1;
                    const isHighBreak = todayClose > highestHigh20;
                    isBreakoutSignal = !isLongSignalBase && (isR1Break || isHighBreak) && isVolumeHigh_1_5 && adx_today > 20;

                    // --- 勢いの判定 ---
                    const rsiValid = rsiArray.filter(v => typeof v === 'number');
                    if (rsiValid.length >= 4) {
                        const rsi_3days_ago = rsiValid[rsiValid.length - 4];
                        if (rsi_today > 50 && rsi_today > rsi_3days_ago) momentum.short = 'up';
                        else if (rsi_today < 50 && rsi_today < rsi_3days_ago) momentum.short = 'down';
                    }

                    if (macdResult && macdResult.histArray) {
                         const histValid = macdResult.histArray.filter(v => typeof v === 'number');
                         if (histValid.length >= 4) {
                             const hist_today_val = histValid[histValid.length - 1]; 
                             const hist_3days_ago = histValid[histValid.length - 4];
                             
                             if (hist_today_val > 0 && hist_today_val > hist_3days_ago) momentum.mid = 'up';
                             else if (hist_today_val < 0 && hist_today_val < hist_3days_ago) momentum.mid = 'down';
                         }
                    }
                    
                    // --- シグナル根拠詳細の構築 (新しいロジック) ---
                    signalDetails = {
                        macd: { 
                            line: macd_today, 
                            signal: signal_today, 
                            cross: macdCrossDistance,
                            state: (macdCrossDistance > 0 ? '買い圧力' : '売り圧力') + ' ' + (Math.abs(macdCrossDistance) > 0.05 * todayClose ? '(強)' : '(弱)'),
                            crossType: isLongCross ? 'GC' : (isShortCross ? 'DC' : 'なし')
                        },
                        rsi: {
                            current: rsi_today,
                            change: rsi_today - rsi_yesterday,
                            trend: rsi_today > rsi_yesterday ? '上昇傾向' : (rsi_today < rsi_yesterday ? '下降傾向' : '横ばい')
                        },
                        volume: {
                            today: todayVolume,
                            vma20: vma20,
                            ratio: volumeRatio,
                            highVolume: volumeRatio >= 1.5 ? '高' : (volumeRatio >= 1.2 ? '中' : '低')
                        },
                        ma25: {
                            sma25: sma25,
                            change: (sma25 - sma25_yesterday) / sma25_yesterday * 100,
                            trend: sma25 > sma25_yesterday ? '上向き' : (sma25 < sma25_yesterday ? '下向き' : '横ばい')
                        },
                        adx: {
                            adx: adx_today,
                            strength: adx_today > 25 ? '強いトレンド' : (adx_today < 20 ? '弱い/レンジ' : 'トレンド継続')
                        }
                    };

                    
                    // --- 特徴リストの判定 (主要特徴は削除されるため、ここではロジックを保持するが、UIには表示されない) ---
                    // if (isLongCross) features.push({ key: 'GC', label: 'MACDゴールデンクロス (買い)', color: 'text-gray-700', dot: 'bg-green-400' });
                    // if (macd_today > 0) features.push({ key: 'MACD-0+', label: 'MACD: 0ラインを上回る', color: 'text-gray-700', dot: 'bg-green-400' });
                    // ... (featuresリストの構築ロジックは削除しないが、UIのHTMLを削除する)
                    
                    // --- バックテスト/確率計算 ---
                    const periodSelectElement = card ? card.querySelector('[data-action="period-select"]') : null;
                    const periodDays = parseInt(periodSelectElement ? periodSelectElement.value : '30'); 
                    const signalIndex = chronoPrices.findLastIndex(v => typeof v === 'number');
                    probability = calculateProbabilities(chronoPrices, signalIndex, periodDays);
                    
                    
                } catch (error) {
                    console.error(`Error checking daily data for ${stock.fullSymbol}:`, error);
                    dailyDataFetchError = true;
                    // エラー発生時は、日足分析をスキップし、短期変動とポジションチェックのみを試みる
                    todayClose = currentPrice;
                    trendSummary = dummyTrend;
                }
                
                // --- 2. ロジック分岐 ---
                
                let strength = 0;
                let signalType = null; 
                let statusType = 'idle';
                
                // 1. ポジション保有中の場合、決済シグナルをチェック (日足データが揃っている場合のみ)
                if (stockInWatchlist.position && !dailyDataFetchError && atr_today && todayClose) {
                    let { type, entryPrice, stopLoss, profitTarget } = stockInWatchlist.position; 
                    let exitSignal = null;

                    if (type === 'LONG') {
                        const trailingStop = todayClose - (atr_today * 2);
                        if (trailingStop > stopLoss) {
                            stopLoss = trailingStop; 
                            stockInWatchlist.position.stopLoss = stopLoss; 
                        }
                        if (todayClose < stopLoss) {
                            exitSignal = { type: 'STOP_LOSS_LONG', message: `損切り (L): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                        } else if (todayClose > profitTarget) {
                            exitSignal = { type: 'PROFIT_TAKE_LONG', message: `利確 (L): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                        } else if (macdResult && isShortSignalBase) { 
                            exitSignal = { type: 'EXIT_LONG', message: `反対シグナル (L): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                        }
                    } else if (type === 'SHORT') {
                        const trailingStop = todayClose + (atr_today * 2);
                        if (trailingStop < stopLoss) {
                            stopLoss = trailingStop; 
                            stockInWatchlist.position.stopLoss = stopLoss; 
                        }
                        if (todayClose > stopLoss) {
                            exitSignal = { type: 'STOP_LOSS_SHORT', message: `損切り (S): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                        } else if (todayClose < profitTarget) {
                            exitSignal = { type: 'PROFIT_TAKE_SHORT', message: `利確 (S): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                        } else if (macdResult && isLongSignalBase) { 
                            exitSignal = { type: 'EXIT_SHORT', message: `反対シグナル (S): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                        }
                    }

                    if (exitSignal) {
                        stockInWatchlist.position = null; 
                        saveWatchlist(); 
                        const exitPriceMsg = `決済価格: ${todayClose.toFixed(2)}`;
                        switch (exitSignal.type) {
                            case 'STOP_LOSS_LONG':
                            case 'STOP_LOSS_SHORT':
                                statusType = 'stop-loss';
                                signalType = exitPriceMsg;
                                break;
                            case 'PROFIT_TAKE_LONG':
                            case 'PROFIT_TAKE_SHORT':
                                statusType = 'profit-take';
                                signalType = exitPriceMsg;
                                break;
                            case 'EXIT_LONG':
                            case 'EXIT_SHORT':
                                statusType = 'exit';
                                signalType = `反対シグナル決済 @ ${todayClose.toFixed(2)}`;
                                break;
                        }
                    } else {
                        saveWatchlist();
                        const sl = stockInWatchlist.position.stopLoss.toFixed(2);
                        const pt = stockInWatchlist.position.profitTarget.toFixed(2);
                        statusType = (stockInWatchlist.position.type === 'LONG') ? 'holding-long' : 'holding-short';
                        signalType = `損切: ${sl} / 利確: ${pt}`;
                    }
                } 
                
                // 2. ポジション非保有の場合、新規エントリーシグナルをチェック (日足データが揃っている場合のみ)
                if (stockInWatchlist.position === null && !dailyDataFetchError && macdResult && atr_today && highestHigh20 && bb_today && pivots && adx_today && sma25 && todayClose) {
                    
                    if (adx_today > 25) strength += 1; 
                    else if (adx_today < 20) strength = Math.max(0, strength - 1); 
                    
                    const isExpanding = bb_today.bandwidth > bb_today.bandwidth_5days_ago;
                    if (isExpanding) strength += 1; 

                    if (isLongSignalBase) {
                        signalType = 'MACDクロス'; 
                        strength += 1; 
                        if (macdResult.today.macd > 0) strength += 1;
                        if (sma25 > sma25_5days_ago) strength += 1;
                        if (isRsiInRange) strength += 1; 
                        if (isVolumeHigh_2_0) strength += 2;
                        else if (isVolumeHigh_1_5) strength += 1;
                        
                    } else if (isBreakoutSignal) {
                        signalType = 'R1ブレイク'; 
                        strength = 1; 
                        if (adx_today > 25) strength += 1; 
                        if (sma25 > sma25_5days_ago) strength += 1; 
                        if (rsi_today > 50) strength += 1;
                        if (isVolumeHigh_2_0) strength += 2;
                        else strength += 1;
                        if (isExpanding) strength += 1;
                        
                    } else if (isShortSignalBase) {
                        signalType = 'MACDクロス(売)'; 
                        strength += 1; 
                        if (macdResult.today.macd < 0) strength += 1;
                        if (sma25 < sma25_5days_ago) strength += 1;
                        if (isRsiInRange) strength += 1;
                        if (isVolumeHigh_2_0) strength += 2;
                        else if (isVolumeHigh_1_5) strength += 1;
                    }
                    
                    if (strength >= ENTRY_STRENGTH_THRESHOLD) {
                        
                        if (isLongSignalBase || isBreakoutSignal) {
                            const stopLoss = (todayClose - (atr_today * 2));
                            const profitTarget = (todayClose + (atr_today * 4)); 
                            
                            stockInWatchlist.position = { type: 'LONG', entryPrice: todayClose, stopLoss: stopLoss, profitTarget: profitTarget };
                            saveWatchlist();

                            statusType = 'signal-long';
                            signalType = `買い (${signalType}) (SL: ${stopLoss.toFixed(2)} / PT: ${profitTarget.toFixed(2)})`;

                        } else if (isShortSignalBase) {
                            const stopLoss = (todayClose + (atr_today * 2));
                            const profitTarget = (todayClose - (atr_today * 4)); 
                            
                            stockInWatchlist.position = { type: 'SHORT', entryPrice: todayClose, stopLoss: stopLoss, profitTarget: profitTarget };
                            saveWatchlist();
                    
                            statusType = 'signal-short';
                            signalType = `売り (${signalType}) (SL: ${stopLoss.toFixed(2)} / PT: ${profitTarget.toFixed(2)})`;
                        }
                    }
                }
                
                if (dailyDataFetchError) {
                     statusType = 'error';
                     signalType = '日足データエラー';
                }
                
                updateCardStatus(stock.id, statusType, signalType, todayClose.toFixed(2), trendSummary, shortTermSignal, strength, 0, 0, dayHigh, dayLow, todayVolume, momentum, pivots, features, probability, signalDetails);

                // --- シグナル一覧の更新 ---
                updateSignalSummary(stock.id, stock.symbol, statusType, shortTermSignal);
            }

            /** シグナルサマリーを更新 */
            function updateSignalSummary(stockId, stockSymbol, statusType, shortTermSignal) {
                // shortTermSignal が null の場合に備えてデフォルト値を設定
                const defaultShortTermSignal = { changeValue: 0, icon: '〰', change: '0.00%' };
                const stSignal = shortTermSignal || defaultShortTermSignal;

                let currentSummary = watchlist.filter(s => s.statusType === 'signal-long' || s.statusType === 'signal-short');
                
                // 短期シグナルも加味
                if (stSignal.changeValue >= SHORT_TERM_CHANGE_THRESHOLD * 2 || stSignal.changeValue <= -SHORT_TERM_CHANGE_THRESHOLD * 2) {
                     // 既存のシグナルリストに短期シグナルを追加するか、更新する
                     const shortTermKey = `short-${stockId}`;
                     
                     let shortTermStatus = 'short-signal-long';
                     let shortTermMessage = `短期${stSignal.icon} (${stSignal.change})`;
                     
                     if (stSignal.changeValue < 0) {
                         shortTermStatus = 'short-signal-short';
                         shortTermMessage = `短期${stSignal.icon} (${stSignal.change})`;
                     }
                     
                     if (!currentSummary.some(s => s.id === shortTermKey)) {
                          currentSummary.push({ 
                            id: shortTermKey, 
                            symbol: stockSymbol, 
                            statusType: shortTermStatus, 
                            message: shortTermMessage,
                            isShortTerm: true
                          });
                     } else {
                         // 既に短期シグナルがある場合はメッセージを更新
                         const existingShort = currentSummary.find(s => s.id === shortTermKey);
                         if (existingShort) {
                            existingShort.statusType = shortTermStatus;
                            existingShort.message = shortTermMessage;
                         }
                     }
                } else {
                    // 短期シグナルが収束したらリストから削除
                    currentSummary = currentSummary.filter(s => s.id !== `short-${stockId}`);
                }
                
                // 日足シグナルの更新
                if (statusType === 'signal-long' || statusType === 'signal-short') {
                     const dailyKey = `daily-${stockId}`;
                     const dailyMessage = (statusType === 'signal-long' ? '日足買シグナル' : '日足売シグナル');
                     if (!currentSummary.some(s => s.id === dailyKey)) {
                         currentSummary.push({ 
                             id: dailyKey, 
                             symbol: stockSymbol, 
                             statusType: statusType, 
                             message: dailyMessage,
                             isShortTerm: false
                         });
                     }
                } else {
                    // 日足シグナルが消えたら削除
                    currentSummary = currentSummary.filter(s => s.id !== `daily-${stockId}`);
                }

                
                // シグナル一覧の再描画
                signalSummaryList.innerHTML = '';
                
                // シグナル一覧のフィルタリングとソート
                const signalStocks = watchlist.filter(stock => 
                    stock.statusType === 'signal-long' || 
                    stock.statusType === 'signal-short' ||
                    (shortTermPriceHistory[stock.id] && checkShortTermSignal(stock.id, shortTermPriceHistory[stock.id].slice(-1)[0]?.price || 0).changeValue >= SHORT_TERM_CHANGE_THRESHOLD * 2) ||
                    (shortTermPriceHistory[stock.id] && checkShortTermSignal(stock.id, shortTermPriceHistory[stock.id].slice(-1)[0]?.price || 0).changeValue <= -SHORT_TERM_CHANGE_THRESHOLD * 2)
                );
                
                if (signalStocks.length > 0) {
                    signalSummaryArea.classList.remove('hidden');
                    
                    const renderedSignals = new Set();
                    
                    signalStocks.sort((a, b) => a.symbol.localeCompare(b.symbol)); 

                    signalStocks.forEach(stock => {
                        // 日足シグナルを表示
                        if (stock.statusType === 'signal-long' || stock.statusType === 'signal-short') {
                            const key = `daily-${stock.id}`;
                            if (!renderedSignals.has(key)) {
                                const dailyMessage = (stock.statusType === 'signal-long' ? '日足買シグナル' : '日足売シグナル');
                                let colorClass = stock.statusType === 'signal-long' ? 'bg-green-200 text-green-800' : 'bg-red-200 text-red-800';
                                
                                const element = document.createElement('span');
                                element.className = `px-3 py-1 rounded-full text-xs font-semibold ${colorClass} shadow-sm cursor-pointer hover:bg-opacity-80 transition`;
                                element.textContent = `${stock.symbol}: ${dailyMessage}`;
                                signalSummaryList.appendChild(element);
                                renderedSignals.add(key);
                            }
                        }
                        
                        // 短期シグナルを表示
                        // 最新の価格がshortTermPriceHistoryに存在するかチェック
                        const latestPrice = shortTermPriceHistory[stock.id] ? shortTermPriceHistory[stock.id].slice(-1)[0]?.price : 0;

                        const stSignalForSummary = checkShortTermSignal(stock.id, latestPrice);
                        if (stSignalForSummary.changeValue >= SHORT_TERM_CHANGE_THRESHOLD * 2 || stSignalForSummary.changeValue <= -SHORT_TERM_CHANGE_THRESHOLD * 2) {
                            const key = `short-${stock.id}`;
                            if (!renderedSignals.has(key)) {
                                let shortTermStatus = stSignalForSummary.changeValue > 0 ? 'short-signal-long' : 'short-signal-short';
                                let shortTermMessage = `短期${stSignalForSummary.icon} (${stSignalForSummary.change})`;
                                let colorClass = shortTermStatus === 'short-signal-long' ? 'bg-green-200 text-green-800' : 'bg-red-200 text-red-800';

                                const element = document.createElement('span');
                                element.className = `px-3 py-1 rounded-full text-xs font-semibold ${colorClass} shadow-sm cursor-pointer hover:bg-opacity-80 transition`;
                                element.textContent = `${stock.symbol}: ${shortTermMessage}`;
                                signalSummaryList.appendChild(element);
                                renderedSignals.add(key);
                            }
                        }
                    });

                } else {
                    signalSummaryArea.classList.add('hidden');
                    signalSummaryList.innerHTML = '<p class="text-indigo-600 text-sm">現在、新規エントリーシグナルが出ている銘柄はありません。</p>';
                }
                
                // ウォッチリストのステータスに保存 (一時的なもので、localStorageには保存しない)
                const stockIndex = watchlist.findIndex(s => s.id === stockId);
                if (stockIndex !== -1) {
                     watchlist[stockIndex].statusType = statusType;
                }
            }


            // --- UI更新 ---

            /** ウォッチリストを再描画 */
            function renderWatchlist() {
                watchlistContainer.innerHTML = '';
                if (watchlist.length === 0) {
                    watchlistContainer.innerHTML = '<p class="text-gray-500 col-span-full no-stocks-message">監視中の銘柄はありません。</p>';
                    return;
                }

                watchlist.forEach(stock => {
                    renderSingleStock(stock); 
                });
            }

            /** 単一の銘柄カードを描画してDOMに追加 */
            function renderSingleStock(stock) {
                const noStocksMessage = watchlistContainer.querySelector('.no-stocks-message');
                if (noStocksMessage) noStocksMessage.remove();

                const card = document.createElement('div');
                card.id = `card-${stock.id}`;
                // カードを大きくするため、パディングを増やし、全体的な高さを確保
                card.className = 'bg-white p-5 rounded-xl shadow-lg ring-1 ring-gray-200 transition-all'; 
                
                // UI改善: 価格、短期トレンド、日足トレンドを明確に分離
                card.innerHTML = `
                    <div class="flex justify-between items-start mb-3 border-b border-gray-100 pb-3">
                        <div>
                            <h3 class="text-xl font-extrabold leading-6 text-gray-900">${stock.symbol} <span class="text-base font-normal text-gray-500">(${stock.market})</span></h3>
                        </div>
                        <div class="flex items-center space-x-2"> 
                             <div class="loader w-4 h-4 rounded-full border-3 border-gray-200 hidden" data-status="loader"></div>
                             <button data-action="remove" data-id="${stock.id}" class="text-gray-400 hover:text-red-500 transition-colors">
                                 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                             </button>
                        </div>
                    </div>

                    <!-- シグナル/ポジション表示 (最上部に移動) -->
                    <div class="mb-3 p-2 bg-indigo-50/70 rounded-lg">
                        <p class="text-base font-bold leading-6 text-indigo-700" data-status="signal">--</p>
                    </div>

                    <!-- メイン価格 & 短期変動エリア -->
                    <div class="grid grid-cols-3 gap-3 items-start border-b border-gray-200 pb-3 mb-3">
                        <!-- 価格と日足トレンド -->
                        <div class="col-span-1 flex flex-col">
                            <p class="text-4xl font-extrabold leading-9" data-status="price">--.--</p>
                            <!-- 日足トレンドを大きく、価格の真下に配置 -->
                            <div class="flex items-end space-x-1 mt-1">
                                <p class="text-lg font-extrabold" data-status="trend-value">--</p>
                                <p class="text-xs font-semibold leading-5" data-status="trend-text">日足トレンド</p>
                            </div>
                        </div>

                        <!-- 短期変動 (中央) -->
                        <div class="col-span-1 flex flex-col text-center border-l border-r border-gray-200 px-3">
                             <p class="text-xs font-bold text-gray-500 mb-1">短期(10分)変動</p>
                             <div class="flex flex-col items-center justify-center h-full">
                                <div class="flex items-center">
                                    <span class="text-lg font-semibold" data-status="short-term-icon">...</span>
                                    <span class="text-xl font-extrabold ml-1" data-status="short-term-change">--%</span>
                                </div>
                                <span class="text-xs font-semibold mt-0.5" data-status="short-term-text">取得中</span>
                            </div>
                        </div>

                        <!-- 短期支持抵抗ライン (右) -->
                        <div class="col-span-1 text-right space-y-1 text-sm font-medium">
                            <p class="text-red-600 leading-5" data-status="short-high">短期抵抗: <span class="font-extrabold">--</span></p>
                            <p class="text-green-600 leading-5" data-status="short-low">短期支持: <span class="font-extrabold">--</span></p>
                            <p class="text-gray-700 leading-5" data-status="strength">勢い: <span class="font-extrabold text-indigo-600">--</span></p>
                        </div>
                    </div>


                    <!-- 詳細分析ブロック - 2x2グリッドに変更 -->
                    <div class="grid grid-cols-2 gap-4 items-start mb-3">
                        
                        <!-- 1. 日足支持抵抗/高安 -->
                        <div class="flex flex-col space-y-1 text-sm font-medium border border-gray-200 p-3 rounded-lg bg-gray-50">
                            <p class="font-bold text-gray-800 mb-1">日足ライン / 高安</p>
                            <p class="text-red-600 leading-4" data-status="pivot-r1">抵抗1: <span class="font-extrabold">--</span></p>
                            <p class="text-green-600 leading-4" data-status="pivot-s1">支持1: <span class="font-extrabold">--</span></p>
                            <div class="border-t border-gray-200 pt-1 mt-1">
                                <p class="text-gray-700 leading-4" data-status="day-high-low">DH: <span class="font-extrabold">--</span> / DL: <span class="font-extrabold">--</span></p>
                                <p class="text-gray-700 leading-4" data-status="volume">Vol: <span class="font-extrabold">--</span></p>
                            </div>
                        </div>
                        
                        <!-- 2. 勝率表示エリア -->
                        <div class="p-3 rounded-lg border border-gray-200 shadow-inner prob-container bg-white">
                            <p class="text-xs font-bold text-gray-700 mb-1" data-status="probability-title">利益/損失 確率 (過去分析)</p>
                            
                            <div class="flex items-center justify-between mb-1">
                                <p class="text-xs font-semibold text-gray-500" data-status="probability-detail-label">1ヶ月後 (194例)</p>
                                <select data-id="${stock.id}" data-action="period-select" class="text-xs font-medium text-gray-700 px-1 py-0 border border-gray-300 rounded-md bg-white hover:border-indigo-500 h-6">
                                    <option value="7">1W</option>
                                    <option value="30" selected>1M</option>
                                    <option value="250">1Y</option>
                                </select>
                            </div>
                            
                            <div class="flex justify-between items-center space-x-1 border-t border-gray-100 pt-1"> 
                                <div class="flex-1 text-center">
                                    <p class="text-xs text-gray-500">利益率</p>
                                    <p class="text-lg font-extrabold text-green-700" data-status="win-rate">-</p>
                                </div>
                                <div class="flex-1 text-center border-l border-gray-200">
                                    <p class="text-xs text-gray-500">損失率</p>
                                    <p class="text-lg font-extrabold text-red-700" data-status="loss-rate">-</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 3. シグナル根拠リスト (新しいセクション) -->
                        <div class="col-span-2">
                             <p class="text-xs font-semibold text-gray-700 mb-1">【シグナル根拠】<span class="font-normal text-indigo-500">(エントリー判定の根拠数値)</span>:</p>
                            <div data-status="signal-details" class="space-y-1 p-2 rounded-lg bg-indigo-50 border border-indigo-200">
                                <p class="text-xs text-gray-400">日足データ取得中...</p>
                            </div>
                        </div>
                        
                        <!-- 4. (削除された主要特徴のスペースを確保) -->
                        <!-- <div class="col-span-2">
                            <p class="text-xs font-semibold text-gray-700 mb-1 mt-3">主要特徴 (削除済):</p>
                            <ul data-status="features-list" class="space-y-0.5 grid grid-cols-3 gap-x-2 text-xs">
                                <li class="text-xs text-gray-400 leading-4 col-span-3">（このスペースはシグナル根拠に集約されました）</li>
                            </ul>
                        </div> -->

                    </div>
                    
                    <!-- ニュースボタン -->
                    <div class="mt-2">
                         <button data-action="fetch-news" data-id="${stock.id}" data-symbol="${stock.symbol}" data-full-symbol="${stock.fullSymbol}" class="bg-blue-500 hover:bg-blue-600 text-white text-sm font-bold py-2 px-3 rounded-lg shadow-md transition duration-150 ease-in-out w-full">
                            <span data-status="news-button-text">最新ニュースを検索 (Gemini)</span>
                        </button>
                    </div>

                    <!-- プログレスバー -->
                    <div class="w-full bg-gray-200 rounded-full h-1 mt-4 overflow-hidden">
                        <div data-status="progress-bar" class="bg-blue-600 h-1 rounded-full" style="width: 0%; transition: width 0.1s linear;"></div>
                    </div>
                `;
                watchlistContainer.appendChild(card);
                
                // 初期ローディング前にPosition情報を設定
                if (stock.position) {
                    const sl = stock.position.stopLoss.toFixed(2);
                    const pt = stock.position.profitTarget.toFixed(2);
                    const dummyTrend = { text: '', icon: '↔', color: 'text-gray-500', value: 0 };
                    const dummyShortTerm = { text: '取得中', icon: '...', color: 'text-gray-500', change: '--%', changeValue: 0, high: null, low: null };
                    if (stock.position.type === 'LONG') {
                         updateCardStatus(stock.id, 'holding-long', `損切: ${sl} / 利確: ${pt}`, stock.position.entryPrice.toFixed(2), dummyTrend, dummyShortTerm, 0, 0, 0, null, null, null, null, null, [], null, {});
                    } else {
                         updateCardStatus(stock.id, 'holding-short', `損切: ${sl} / 利確: ${pt}`, stock.position.entryPrice.toFixed(2), dummyTrend, dummyShortTerm, 0, 0, 0, null, null, null, null, null, [], null, {});
                    }
                }
            }
            
            /** 銘柄カードのステータスを更新 */
            function updateCardStatus(stockId, statusType, signalType, price, trendSummary, shortTermSignal, strength = 0, stopLoss = 0, profitTarget = 0, dayHigh = null, dayLow = null, todayVolume = null, momentum = null, pivots = null, features = [], probability = null, signalDetails = {}) { 
                const card = document.getElementById(`card-${stockId}`);
                if (!card) return;

                const priceText = card.querySelector('[data-status="price"]');
                const signalText = card.querySelector('[data-status="signal"]');
                const loader = card.querySelector('[data-status="loader"]');
                const highLowText = card.querySelector('[data-status="day-high-low"]');
                const volumeText = card.querySelector('[data-status="volume"]');
                const pivotR1Text = card.querySelector('[data-status="pivot-r1"]');
                const pivotS1Text = card.querySelector('[data-status="pivot-s1"]');
                const strengthText = card.querySelector('[data-status="strength"]');
                
                const trendText = card.querySelector('[data-status="trend-text"]'); 
                const trendValueText = card.querySelector('[data-status="trend-value"]'); 
                // const featuresList = card.querySelector('[data-status="features-list"]'); // 削除された要素
                const signalDetailsList = card.querySelector('[data-status="signal-details"]'); 
                const winRateText = card.querySelector('[data-status="win-rate"]');
                const lossRateText = card.querySelector('[data-status="loss-rate"]');
                const probabilityTitle = card.querySelector('[data-status="probability-title"]');
                const probabilityDetailLabel = card.querySelector('[data-status="probability-detail-label"]'); 
                
                const shortTermIcon = card.querySelector('[data-status="short-term-icon"]');
                const shortTermText = card.querySelector('[data-status="short-term-text"]');
                const shortTermChange = card.querySelector('[data-status="short-term-change"]');
                const shortHighText = card.querySelector('[data-status="short-high"]');
                const shortLowText = card.querySelector('[data-status="short-low"]');
                
                const newsButton = card.querySelector('[data-action="fetch-news"]'); 
                const newsButtonText = card.querySelector('[data-status="news-button-text"]');

                signalText.className = 'text-base font-bold leading-6'; 
                loader.classList.add('hidden');
                card.classList.remove('bg-green-50', 'bg-red-50', 'bg-yellow-50', 'bg-blue-50', 'border-green-400', 'border-red-400', 'border-yellow-400', 'bg-gray-100', 'border-gray-400', 'border-blue-400'); 
                card.style.borderWidth = "0px";
                
                if (price !== '--.--') priceText.textContent = price;

                // ニュースボタンをリセット
                if (newsButton) {
                    newsButton.disabled = false;
                    newsButtonText.innerHTML = '最新ニュースを検索 (Gemini)'; 
                }
                
                // --- 短期変動表示の更新 ---
                if (shortTermSignal && shortTermIcon && shortTermText && shortTermChange) {
                    shortTermIcon.textContent = shortTermSignal.icon;
                    shortTermIcon.className = `text-lg font-semibold ${shortTermSignal.color}`;
                    shortTermText.textContent = shortTermSignal.text;
                    shortTermText.className = `text-xs font-semibold mt-0.5 ${shortTermSignal.color}`;
                    
                    shortTermChange.textContent = shortTermSignal.change;
                    shortTermChange.className = `text-xl font-extrabold ml-1 ${shortTermSignal.changeValue > 0 ? 'text-green-600' : (shortTermSignal.changeValue < 0 ? 'text-red-600' : 'text-gray-500')}`;
                    
                    if (shortHighText) shortHighText.innerHTML = `短期抵抗: <span class="font-extrabold">${shortTermSignal.high !== null ? shortTermSignal.high.toFixed(2) : '--'}</span>`;
                    if (shortLowText) shortLowText.innerHTML = `短期支持: <span class="font-extrabold">${shortTermSignal.low !== null ? shortTermSignal.low.toFixed(2) : '--'}</span>`;
                }


                // --- 日足トレンド表示の更新 ---
                if (trendSummary && trendText && trendValueText) {
                    trendText.textContent = `${trendSummary.icon}トレンド`; // テキストを「トレンド」に変更し、矢印を前に配置
                    trendText.className = `text-xs font-semibold leading-5 ${trendSummary.color}`;
                    
                    if (trendSummary.value !== 0) {
                        const sign = trendSummary.value > 0 ? '+' : '';
                        const colorClass = trendSummary.value > 0 ? 'text-green-600' : (trendSummary.value < 0 ? 'text-red-600' : 'text-gray-500');
                        trendValueText.textContent = `${sign}${trendSummary.value.toFixed(2)}%`;
                        trendValueText.className = `text-lg font-extrabold ${colorClass}`; 
                    } else {
                        trendValueText.textContent = `0.00%`;
                        trendValueText.className = `text-lg font-extrabold text-gray-500`; 
                    }
                }
                
                // --- 勢いの表示 ---
                if (strengthText) {
                    let strengthMessage = '低';
                    let strengthColor = 'text-gray-500';
                    if (strength >= 3) { strengthMessage = '高'; strengthColor = 'text-green-600'; }
                    else if (strength >= 1) { strengthMessage = '中'; strengthColor = 'text-indigo-600'; }
                    strengthText.innerHTML = `勢い: <span class="font-extrabold ${strengthColor}">${strengthMessage} (${strength})</span>`;
                }


                // --- シグナル根拠リストの更新 ---
                if (signalDetailsList && Object.keys(signalDetails).length > 0) {
                    let html = '';
                    
                    // 1. MACD
                    const macdColor = signalDetails.macd.cross > 0 ? 'check-green' : (signalDetails.macd.cross < 0 ? 'check-red' : 'text-gray-500');
                    const macdCrossLabel = signalDetails.macd.crossType === 'GC' ? 'GC (買い)' : (signalDetails.macd.crossType === 'DC' ? 'DC (売り)' : '安定');

                    html += `<div class="grid grid-cols-2 text-xs">
                        <span class="${macdColor} font-bold col-span-2 flex items-center mb-1">MACD: ${macdCrossLabel} (${signalDetails.macd.cross > 0 ? '+' : ''}${signalDetails.macd.cross.toFixed(3)} 距離)</span>
                        <span class="text-gray-700 ml-2">MACDライン: ${signalDetails.macd.line.toFixed(3)}</span>
                        <span class="text-gray-700">シグナルライン: ${signalDetails.macd.signal.toFixed(3)}</span>
                    </div>`;

                    // 2. 出来高
                    const volColor = signalDetails.volume.ratio >= 1.5 ? 'check-green' : (signalDetails.volume.ratio < 0.8 ? 'check-red' : 'text-gray-700');
                    const volRatioText = signalDetails.volume.ratio.toFixed(1);
                    html += `<div class="grid grid-cols-2 text-xs border-t border-indigo-100 pt-1 mt-1">
                        <span class="${volColor} font-bold col-span-2">出来高: ${signalDetails.volume.highVolume} (平均${volRatioText}倍)</span>
                        <span class="text-gray-700 ml-2">当日出来高: ${formatVolume(signalDetails.volume.today)}</span>
                        <span class="text-gray-700">20日平均: ${formatVolume(signalDetails.volume.vma20)}</span>
                    </div>`;
                    
                    // 3. RSI / ADX / MA25
                    const rsiColor = signalDetails.rsi.change > 0 ? 'check-green' : (signalDetails.rsi.change < 0 ? 'check-red' : 'text-gray-700');
                    const rsiChangeSign = signalDetails.rsi.change > 0 ? '+' : '';
                    const maColor = signalDetails.ma25.change > 0 ? 'check-green' : (signalDetails.ma25.change < 0 ? 'check-red' : 'text-gray-700');
                    const maSign = signalDetails.ma25.change > 0 ? '+' : '';
                    
                    html += `<div class="grid grid-cols-2 text-xs border-t border-indigo-100 pt-1 mt-1">
                        <span class="${rsiColor} font-bold col-span-2">RSI: ${signalDetails.rsi.current.toFixed(0)} (${rsiChangeSign}${signalDetails.rsi.change.toFixed(1)} ${signalDetails.rsi.trend})</span>
                        <span class="text-gray-700 ml-2">ADX: ${signalDetails.adx.adx.toFixed(0)} (${signalDetails.adx.strength})</span>
                        <span class="${maColor} ml-2">SMA25: ${maSign}${signalDetails.ma25.change.toFixed(2)}% (${signalDetails.ma25.trend})</span>
                    </div>`;

                    signalDetailsList.innerHTML = html;
                } else if (signalDetailsList) {
                    signalDetailsList.innerHTML = '<p class="text-xs text-gray-400">日足データ取得中...</p>';
                }


                // --- 主要特徴リストの更新 (DOMは残るが中身は空にする) ---
                const featuresList = card.querySelector('[data-status="features-list"]');
                if (featuresList) {
                    featuresList.innerHTML = `<li class="text-xs text-gray-400 leading-4 col-span-3">（このスペースはシグナル根拠に集約されました）</li>`;
                }


                // --- 確率の更新 ---
                if (probability && probabilityTitle && probabilityDetailLabel && winRateText && lossRateText) {
                    probabilityTitle.textContent = `利益/損失 確率 (過去分析)`;

                    if (probability.total > 0) {
                        const winPercentage = probability.winRate.toFixed(1);
                        const lossPercentage = probability.lossRate.toFixed(1);

                        // [修正] 数値の太さを強調
                        winRateText.textContent = `${winPercentage}%`;
                        lossRateText.textContent = `${lossPercentage}%`;
                        winRateText.classList.add('font-extrabold');
                        lossRateText.classList.add('font-extrabold');
                        
                        let periodLabel = '1週間後';
                        if (probability.period === 30) periodLabel = '1ヶ月後';
                        if (probability.period === 250) periodLabel = '1年後'; 
                        
                        probabilityDetailLabel.textContent = `${periodLabel} (${probability.total}例)`;

                        if (parseFloat(winPercentage) === 0) winRateText.textContent = '-';
                        if (parseFloat(lossPercentage) === 0) lossRateText.textContent = '-';

                    } else {
                        probabilityDetailLabel.textContent = `データ不足`;
                        winRateText.textContent = '-';
                        lossRateText.textContent = '-';
                    }

                } else if (probabilityTitle && probabilityDetailLabel && winRateText && lossRateText) {
                    probabilityTitle.textContent = `利益/損失 確率 (過去分析)`;
                    probabilityDetailLabel.textContent = `データなし`;
                    winRateText.textContent = '-';
                    lossRateText.textContent = '-';
                }

                // --- 価格・出来高・ピボットの更新 ---
                if (highLowText) {
                    if (typeof dayHigh === 'number' && typeof dayLow === 'number') highLowText.innerHTML = `DH: <span class="font-extrabold">${dayHigh.toFixed(2)}</span> / DL: <span class="font-extrabold">${dayLow.toFixed(2)}</span>`;
                    else highLowText.innerHTML = 'DH: <span class="font-extrabold">--</span> / DL: <span class="font-extrabold">--</span>';
                }
                if (volumeText) {
                    if (typeof todayVolume === 'number') volumeText.innerHTML = `Vol: <span class="font-extrabold">${formatVolume(todayVolume)}</span>`;
                    else volumeText.innerHTML = 'Vol: <span class="font-extrabold">--</span>';
                }
                if (pivotR1Text && pivotS1Text) {
                    if (pivots && typeof pivots.r1 === 'number' && typeof pivots.s1 === 'number') {
                        pivotR1Text.innerHTML = `抵抗1: <span class="font-extrabold">${pivots.r1.toFixed(2)}</span>`;
                        pivotS1Text.innerHTML = `支持1: <span class="font-extrabold">${pivots.s1.toFixed(2)}</span>`;
                    } else {
                        pivotR1Text.innerHTML = '抵抗1: <span class="font-extrabold">--</span>';
                        pivotS1Text.innerHTML = '支持1: <span class="font-extrabold">--</span>';
                    }
                }


                let signalMessage = signalType; 

                switch (statusType) {
                    case 'loading':
                        signalMessage = '更新中...';
                        signalText.className = 'text-base font-bold leading-6 text-blue-600';
                        loader.classList.remove('hidden');
                        break;
                    case 'idle':
                        signalMessage = 'シグナルなし';
                        signalText.className = 'text-base font-bold leading-6 text-gray-600';
                        break;
                    case 'signal-long': 
                        signalMessage = signalType; 
                        signalText.className = 'text-base font-bold leading-6 text-green-700';
                        card.classList.add('bg-green-50', 'border-green-400');
                        card.style.borderWidth = "2px";
                        break;
                    case 'signal-short': 
                        signalMessage = signalType; 
                        signalText.className = 'text-base font-bold leading-6 text-red-700';
                        card.classList.add('bg-red-50', 'border-red-400');
                        card.style.borderWidth = "2px";
                        break;
                    case 'holding-long': 
                        signalMessage = `L ポジション保有中: ${signalType}`; 
                        signalText.className = 'text-base font-bold leading-6 text-green-700';
                        card.classList.add('bg-green-50'); 
                        break;
                    case 'holding-short': 
                        signalMessage = `S ポジション保有中: ${signalType}`; 
                        signalText.className = 'text-base font-bold leading-6 text-red-700';
                        card.classList.add('bg-red-50');
                        break;
                    case 'error':
                        signalMessage = signalType; 
                        signalText.className = 'text-base font-bold leading-6 text-yellow-800';
                        card.classList.add('bg-yellow-50', 'border-yellow-400');
                        card.style.borderWidth = "2px";
                        break;
                    case 'profit-take':
                        signalMessage = `利確決済完了: ${signalType}`; 
                        signalText.className = 'text-base font-bold leading-6 text-blue-700';
                        card.classList.add('bg-blue-50', 'border-blue-400');
                        card.style.borderWidth = "2px";
                        break;
                    case 'stop-loss':
                        signalMessage = `損切決済完了: ${signalType}`; 
                        signalText.className = 'text-base font-bold leading-6 text-yellow-800'; 
                        card.classList.add('bg-yellow-50', 'border-yellow-400');
                        card.style.borderWidth = "2px";
                        break;
                    case 'exit':
                        signalMessage = `決済完了: ${signalType}`; 
                        signalText.className = 'text-base font-bold leading-6 text-gray-700';
                        card.classList.add('bg-gray-100', 'border-gray-400');
                        card.style.borderWidth = "2px";
                        break;
                    default:
                        signalMessage = '--';
                }
                signalText.textContent = signalMessage; 
            }
            
            // --- 状態管理 (LocalStorage) ---
            function loadWatchlist() {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    const loaded = JSON.parse(stored);
                    watchlist = loaded.map(stock => ({
                        ...stock,
                        position: stock.position || null,
                        timerId: null,
                        statusType: 'idle' // シグナルサマリー用に初期化
                    }));
                }
            }

            function saveWatchlist() {
                const savableWatchlist = watchlist.map(stock => ({
                    id: stock.id,
                    symbol: stock.symbol,
                    market: stock.market,
                    fullSymbol: stock.fullSymbol,
                    position: stock.position
                }));
                localStorage.setItem(STORAGE_KEY, JSON.stringify(savableWatchlist));
            }

            function checkAllSignalsAndStartTimers(isInitialLoad = false) {
                // 初期ロード時、watchlistが空の場合、nullを渡さずにデフォルトの引数で呼ぶ
                if (watchlist.length === 0) {
                    // shortTermSignal のダミーオブジェクトを渡す
                    const dummyShortTerm = { changeValue: 0, icon: '〰', change: '0.00%' };
                    updateSignalSummary(null, null, 'idle', dummyShortTerm);
                    return;
                }

                let delay = 0;
                const delayIncrement = isInitialLoad ? 2000 : 0; 

                watchlist.forEach(stock => {
                    if (stock.timerId) {
                        clearInterval(stock.timerId);
                        stock.timerId = null;
                    }

                    const exec = () => {
                        checkStockSignal(stock); 
                        startStockTimer(stock); 
                    };

                    if (delayIncrement > 0) {
                         setTimeout(exec, delay);
                         delay += delayIncrement;
                    } else {
                        exec();
                    }
                });
            }


            // --- イベントリスナー ---
            addStockForm.addEventListener('submit', (e) => {
                e.preventDefault();
                formError.textContent = '';
                
                const market = marketSelect.value;
                let symbol = symbolInput.value.trim().toUpperCase();

                if (!symbol) {
                    formError.textContent = '銘柄コードを入力してください。';
                    return;
                }
                
                let fullSymbol = symbol;
                if (market === 'JP' && !symbol.endsWith('.T')) {
                    fullSymbol = `${symbol}.T`;
                }
                
                const id = `${market}-${fullSymbol}`;

                if (watchlist.some(stock => stock.id === id)) {
                    formError.textContent = 'この銘柄は既に追加されています。';
                    return;
                }

                const newStock = { id, symbol, market, fullSymbol, position: null, timerId: null, statusType: 'idle' }; 
                watchlist.push(newStock);
                
                // 短期価格履歴を初期化
                shortTermPriceHistory[id] = [];
                
                saveWatchlist();
                
                renderSingleStock(newStock); 
                
                checkStockSignal(newStock);
                startStockTimer(newStock);

                symbolInput.value = '';
            });

            // モーダルを閉じる
            closeModalButton.addEventListener('click', () => {
                newsModal.classList.add('hidden');
                newsModal.classList.remove('flex');
            });
            // モーダル外のクリックで閉じる (オプション)
            newsModal.addEventListener('click', (e) => {
                if (e.target === newsModal) {
                    newsModal.classList.add('hidden');
                    newsModal.classList.remove('flex');
                }
            });

            watchlistContainer.addEventListener('click', async (e) => {
                const removeButton = e.target.closest('[data-action="remove"]');
                const newsButton = e.target.closest('[data-action="fetch-news"]');

                if (removeButton) {
                    const stockId = removeButton.dataset.id;
                    
                    const stockToRemove = watchlist.find(stock => stock.id === stockId);
                    if (stockToRemove && stockToRemove.timerId) {
                        clearInterval(stockToRemove.timerId); 
                    }
                    
                    // 短期価格履歴を削除
                    delete shortTermPriceHistory[stockId];
                    
                    watchlist = watchlist.filter(stock => stock.id !== stockId);
                    saveWatchlist();
                    
                    const card = document.getElementById(`card-${stockId}`);
                    if (card) {
                        card.remove();
                    }
                    
                    if (watchlist.length === 0) {
                        watchlistContainer.innerHTML = '<p class="text-gray-500 col-span-full no-stocks-message">監視中の銘柄はありません。</p>';
                    }
                    
                    // シグナルサマリーを強制更新
                    const dummyShortTerm = { changeValue: 0, icon: '〰', change: '0.00%' };
                    updateSignalSummary(stockId, stockToRemove.symbol, 'idle', dummyShortTerm);
                } else if (newsButton) {
                    const stockSymbol = newsButton.dataset.symbol;
                    const fullSymbol = newsButton.dataset.fullSymbol;
                    
                    // モーダルを表示し、ローディング状態にする
                    modalTitle.textContent = `${stockSymbol} (${fullSymbol}) のニュース検索結果`;
                    modalNewsContent.innerHTML = `<div class="flex items-center justify-center h-24 text-blue-500">
                        <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        ニュースを検索中...
                    </div>`;
                    modalSourceLinks.innerHTML = '';
                    
                    newsModal.classList.remove('hidden');
                    newsModal.classList.add('flex');
                    newsButton.disabled = true; // ボタンを無効化

                    try {
                        // ニュース検索を実行
                        const { text, sources } = await fetchGeminiNews(stockSymbol);
                        
                        // 結果をモーダルに表示
                        modalNewsContent.innerHTML = `<p class="text-base text-gray-800 leading-relaxed whitespace-pre-wrap">${text}</p>`;

                        if (sources.length > 0) {
                            const linkHtml = sources.map((s, index) => 
                                `<div><span class="font-bold text-gray-800">${index + 1}.</span> <a href="${s.uri}" target="_blank" rel="noopener" class="text-indigo-500 hover:text-indigo-700 hover:underline inline-block">${s.title}</a></div>`
                            ).join('');
                            modalSourceLinks.innerHTML = linkHtml;
                        } else {
                            modalSourceLinks.innerHTML = '引用元情報なし';
                        }
                    } catch (error) {
                        // エラーメッセージをモーダルに表示
                        modalNewsContent.innerHTML = `<p class="text-red-500 text-sm">エラー: ニュース検索に失敗しました。<br>詳細: ${error.message}</p>`;
                        modalSourceLinks.innerHTML = '';
                        console.error("News Fetch Error:", error);
                    } finally {
                        // 検索完了後、ボタンを有効化
                        newsButton.disabled = false;
                    }
                }
            });
            
            // 期間選択の変更イベントを親要素に委譲し、再計算をトリガー
            watchlistContainer.addEventListener('change', (e) => {
                const periodSelect = e.target.closest('[data-action="period-select"]');
                
                if (periodSelect) {
                    const stockId = periodSelect.dataset.id;
                    const stockToUpdate = watchlist.find(stock => stock.id === stockId);
                    
                    if (stockToUpdate) {
                        // 期間変更時、即座にシグナルチェックと確率計算を再実行
                        checkStockSignal(stockToUpdate); 
                    }
                }
            });

            
            // --- 初期化 ---
            function init() {
                loadWatchlist(); 
                renderWatchlist(); 
                checkAllSignalsAndStartTimers(true); 
            }

            init();
        });
    </script>

</body>
</html>