<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>株式シグナルチェッカー (トレンド表示)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* フォント設定 */
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* カスタムローダー */
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spinner 2.5s linear infinite;
            animation: spinner 2.5s linear infinite;
        }

        @-webkit-keyframes spinner {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }

        @keyframes spinner {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-900 min-h-screen pt-32">

    <!-- ヘッダー -->
    <header class="bg-white shadow-md fixed top-0 left-0 right-0 z-10">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
            <!-- タイトルと説明文を変更 -->
            <h1 class="text-2xl font-bold text-gray-900">
                株式シグナルチェッカー (日足・トレンド監視)
            </h1>
            <p class="mt-1 text-sm text-gray-500">MACD、トレンド(5/25MA)、利確/損切りを自動監視します (30秒ごとに自動更新)。</p>
            
            <!-- [削除] 更新ゲージ -->
        </div>
    </header>

    <!-- メインコンテンツ -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">

        <!-- 銘柄追加フォーム -->
        <div class="bg-white p-6 rounded-lg shadow-lg mb-8">
            <h2 class="text-xl font-semibold mb-4">監視銘柄の追加</h2>
            <!-- [変更] md:grid-cols-8 から md:grid-cols-12 に変更 -->
            <form id="add-stock-form" class="grid grid-cols-1 md:grid-cols-12 gap-4 items-end">
                <!-- [変更] md:col-span-2 (変更なしだが 12カラムグリッドの2) -->
                <div class="md:col-span-2">
                    <label for="market-select" class="block text-sm font-medium text-gray-700">市場</label>
                    <select id="market-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm h-12">
                        <option value="US">米国株 (例: AAPL)</option>
                        <option value="JP">日本株 (例: 7203)</option>
                    </select>
                </div>
                <!-- [変更] md:col-span-4 から md:col-span-8 に変更 -->
                <div class="md:col-span-8">
                    <label for="symbol-input" class="block text-sm font-medium text-gray-700">銘柄コード (シンボル)</label>
                    <!-- [変更] leading-9 (line-height: 2.25rem) を追加 -->
                    <input type="text" id="symbol-input" placeholder="AAPL" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm h-12" required>
                </div>
                <!-- [変更] md:col-span-2 (変更なしだが 12カラムグリッドの2) -->
                <div class="md:col-span-2">
                    <button type="submit" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out w-full">
                        追加して監視開始
                    </button>
                </div>
            </form>
            <p id="form-error" class="text-red-500 text-sm mt-2"></p>
        </div>

        <!-- 監視中リスト -->
        <div>
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold">監視中リスト</h2>
            </div>
            <!-- [変更] lg:grid-cols-3 から lg:grid-cols-4 に変更 -->
            <div id="watchlist" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                <!-- 監視中銘柄カードがここに挿入されます -->
                <p class="text-gray-500 col-span-full">監視中の銘柄はありません。</p>
            </div>
        </div>

    </main>

    <!-- フッター -->
    <footer class="bg-white mt-12 border-t border-gray-200">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 text-center text-sm text-gray-500">
            <p>データ提供: <a href="https://finance.yahoo.com/" target="_blank" rel="noopener" class="text-indigo-600 hover:underline">Yahoo Finance</a> (via corsproxy.io)</p>
            <p class="mt-1">免責事項: このツールは情報提供のみを目的としており、投資助言ではありません。取引はご自身の責任において行ってください。</p>
        </div>
    </footer>

    <!-- JSロジック -->
    <script type="module">
        document.addEventListener('DOMContentLoaded', () => {
            // --- 設定 ---
            const STORAGE_KEY = 'stockSignalWatchlist_v2'; // v2 (ポジション情報追加)
            const UPDATE_INTERVAL = 10000; // 10秒 (更新間隔)
            const REFRESH_RATE = 100; // 100ms (ゲージの更新頻度)

            // --- DOM要素 ---
            const addStockForm = document.getElementById('add-stock-form');
            const marketSelect = document.getElementById('market-select');
            const symbolInput = document.getElementById('symbol-input');
            const formError = document.getElementById('form-error');
            const watchlistContainer = document.getElementById('watchlist');
            // [削除] const updateProgressBar = document.getElementById('update-progress-bar');

            // --- アプリケーション状態 ---
            let watchlist = []; 

            // --- APIヘルパー ---
            async function fetchApi(symbol) {
                // 1y (MA計算のため)
                const targetUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?range=1y&interval=1d`;
                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                
                try {
                    const response = await fetch(proxyUrl);
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            throw new Error(`銘柄コード '${symbol}' が見つかりません (404)`);
                        }
                        throw new Error(`HTTP error! (Proxy or Target) status: ${response.status}`);
                    }
                    
                    const data = await response.json(); 
                    
                    if (data.chart.error) {
                        console.error("Yahoo Finance API Error:", data.chart.error);
                        throw new Error(`Yahoo Finance APIエラー: ${data.chart.error.description || data.chart.error.code}`);
                    }
                    
                    if (!data.chart.result || !data.chart.result[0] || !data.chart.result[0].indicators.quote[0]) {
                         throw new Error("Yahoo Financeから有効なデータが返されませんでした。銘柄コードが間違っている可能性があります。");
                    }
                    
                    return data;

                } catch (error) {
                    console.error(`Fetch error for ${proxyUrl}:`, error);
                    if (error.message.includes('Failed to fetch')) {
                        throw new Error("ネットワークエラー。Yahoo Finance API(プロキシ経由)へのアクセスに失敗しました。");
                    }
                    throw error;
                }
            }

            // --- テクニカル指標計算ヘルパー ---
        
            /**
             * 単純移動平均 (SMA) を計算 (単一値、逆順データ用)
             */
            function calculateSMA(data, period) {
                if (!data) return null;

                const validData = [];
                for (let i = 0; i < data.length; i++) {
                    if (typeof data[i] === 'number') {
                        validData.push(data[i]);
                        if (validData.length >= period) {
                            break;
                        }
                    }
                }
                
                if (validData.length < period) return null; // データ不足

                const sum = validData.reduce((acc, val) => acc + val, 0);
                return sum / period;
            }

            /**
             * [修正] 単純移動平均 (SMA) 配列を計算 (時系列データ用)
             * トレンド判定用に復活
             */
            function calculateSMAArray(data, period) {
                if (!data || data.length < period) return new Array(data.length).fill(null);

                let smaArray = new Array(data.length).fill(null);
                
                for (let i = period - 1; i < data.length; i++) {
                    let sum = 0;
                    let count = 0;
                    let hasNull = false;
                    for (let j = 0; j < period; j++) {
                        if (typeof data[i - j] === 'number') {
                            sum += data[i - j];
                            count++;
                        } else {
                            hasNull = true;
                            break; // 期間内にnullがあれば計算しない
                        }
                    }

                    if (!hasNull && count === period) {
                        smaArray[i] = sum / period;
                    }
                }
                return smaArray;
            }

            /**
             * 指数平滑移動平均 (EMA) を計算
             */
            function calculateEMA(data, period) {
                if (!data || data.length < period) return [];

                let k = 2 / (period + 1);
                let emaArray = new Array(data.length).fill(null);
                
                let initialData = [];
                let firstSmaIndex = -1;
                for (let i = 0; i < data.length; i++) {
                    if (typeof data[i] === 'number') {
                        initialData.push(data[i]);
                        if (initialData.length === period) {
                            firstSmaIndex = i;
                            break;
                        }
                    }
                }
                
                if (firstSmaIndex === -1) return []; // データ不足

                let sum = initialData.reduce((acc, val) => acc + val, 0);
                emaArray[firstSmaIndex] = sum / period;
                
                for (let i = firstSmaIndex + 1; i < data.length; i++) {
                    const currentVal = data[i];
                    const prevEma = emaArray[i - 1];

                    if (typeof currentVal === 'number' && typeof prevEma === 'number') {
                        emaArray[i] = (currentVal * k) + (prevEma * (1 - k));
                    } else if (typeof prevEma === 'number') {
                        emaArray[i] = prevEma;
                    }
                }
                return emaArray;
            }
            
            /**
             * MACDを計算
             */
            function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
                if (prices.length < slowPeriod + signalPeriod) return null;

                const emaFast = calculateEMA(prices, fastPeriod); 
                const emaSlow = calculateEMA(prices, slowPeriod);
                
                let macdLineRaw = [];
                let validMacdPoints = [];
                
                for (let i = 0; i < prices.length; i++) {
                    if (typeof emaFast[i] === 'number' && typeof emaSlow[i] === 'number') {
                        const macdVal = emaFast[i] - emaSlow[i];
                        macdLineRaw[i] = macdVal;
                        validMacdPoints.push(macdVal);
                    } else {
                        macdLineRaw[i] = null;
                    }
                }
                
                if (validMacdPoints.length < signalPeriod + 2) return null;

                const signalLineValid = calculateEMA(validMacdPoints, signalPeriod);
                
                let signalLine = new Array(prices.length).fill(null);
                let validIndex = 0;
                for (let i = 0; i < prices.length; i++) {
                    if (typeof macdLineRaw[i] === 'number') {
                         if (typeof signalLineValid[validIndex] === 'number') {
                             signalLine[i] = signalLineValid[validIndex];
                         }
                         validIndex++;
                    }
                }

                let todayData = null;
                let yesterdayData = null;

                for (let i = prices.length - 1; i >= 1; i--) {
                    const macd_i = macdLineRaw[i];
                    const signal_i = signalLine[i];
                    
                    if (typeof macd_i === 'number' && typeof signal_i === 'number') {
                        if (todayData === null) {
                            todayData = { macd: macd_i, signal: signal_i, hist: macd_i - signal_i };
                        } else if (yesterdayData === null) {
                            yesterdayData = { macd: macd_i, signal: signal_i };
                            break;
                        }
                    }
                }
                
                if (todayData === null || yesterdayData === null) {
                    return null;
                }

                return {
                    today: todayData,
                    yesterday: yesterdayData
                };
            }

            /**
             * RSIを計算
             */
            function calculateRSI(prices, period = 14) {
                const validPrices = prices.filter(p => typeof p === 'number');
                if (validPrices.length <= period) return null;
                
                let gains = 0;
                let losses = 0;
                
                for (let i = 1; i <= period; i++) {
                    let change = validPrices[i] - validPrices[i - 1];
                    if (change > 0) {
                        gains += change;
                    } else {
                        losses -= change;
                    }
                }
                
                let avgGain = gains / period;
                let avgLoss = losses / period;
                
                for (let i = period + 1; i < validPrices.length; i++) {
                    let change = validPrices[i] - validPrices[i - 1];
                    let gain = change > 0 ? change : 0;
                    let loss = change < 0 ? -change : 0;
                    
                    avgGain = (avgGain * (period - 1) + gain) / period;
                    avgLoss = (avgLoss * (period - 1) + loss) / period;
                }

                if (avgLoss === 0) return 100;
                let rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }

            /**
             * ATRを計算
             */
            function calculateATR(dailyDataArray, period = 14) {
                if (dailyDataArray.length <= period) return null;
                
                let trValues = [];
                let prevClose = null;

                for (let i = 0; i < dailyDataArray.length; i++) {
                    const data = dailyDataArray[i];
                    
                    if (typeof data.high !== 'number' || typeof data.low !== 'number' || typeof data.close !== 'number') {
                        prevClose = (typeof data.close === 'number') ? data.close : prevClose;
                        continue;
                    }
                    
                    if (prevClose === null) {
                        prevClose = data.close;
                        continue;
                    }
                    
                    const tr1 = data.high - data.low;
                    const tr2 = Math.abs(data.high - prevClose);
                    const tr3 = Math.abs(data.low - prevClose);
                    
                    trValues.push(Math.max(tr1, tr2, tr3));
                    prevClose = data.close;
                }
                
                if (trValues.length < period) return null;

                let relevantTrs = trValues.slice(trValues.length - period * 2);
                if (relevantTrs.length < period) relevantTrs = trValues;
                if (relevantTrs.length < period) return null;

                let atrSum = 0;
                for (let i = 0; i < period; i++) {
                    atrSum += relevantTrs[i];
                }
                let atr = atrSum / period;
                
                for (let i = period; i < relevantTrs.length; i++) {
                    atr = (atr * (period - 1) + relevantTrs[i]) / period;
                }
                
                return atr;
            }

            // --- [削除] パターン認識ヘルパー ---


            // --- [新規] 銘柄ごとの更新タイマー管理 ---
            /**
             * 銘柄カードごとの自動更新タイマーとプログレスバーを開始する
             */
            function startStockTimer(stock) {
                // 既存のタイマーがあれば停止
                if (stock.timerId) {
                    clearInterval(stock.timerId);
                }

                let progress = 0;
                const card = document.getElementById(`card-${stock.id}`);
                const progressBar = card ? card.querySelector('[data-status="progress-bar"]') : null;
                
                if (!progressBar) {
                    console.warn(`ProgressBar not found for ${stock.id}`);
                    return; // カードがDOMにない
                }

                // (UPDATE_INTERVAL / REFRESH_RATE) 回で 100% になる
                const increment = 100 / (UPDATE_INTERVAL / REFRESH_RATE);
                
                // 起動時はゲージを0にリセット (トランジションなし)
                progressBar.style.transition = 'none';
                progressBar.style.width = '0%';
                
                // 1フレーム待ってからトランジションを戻す (次の更新に備える)
                requestAnimationFrame(() => {
                    progressBar.style.transition = `width ${REFRESH_RATE / 1000}s linear`;
                });

                stock.timerId = setInterval(() => {
                    progress += increment;

                    if (progress >= 100) {
                        progress = 0; // リセット
                        checkStockSignal(stock); // API呼び出し実行
                        
                        // ゲージリセット (トランジションなし)
                        progressBar.style.transition = 'none';
                        progressBar.style.width = '0%';

                        // 1フレーム待ってからトランジションを戻す
                        requestAnimationFrame(() => {
                            progressBar.style.transition = `width ${REFRESH_RATE / 1000}s linear`;
                        });
                        
                    } else {
                         // 通常更新 (トランジションあり)
                         progressBar.style.width = `${progress}%`;
                    }

                }, REFRESH_RATE);
            }


            // --- コアロジック: シグナル判定 ---
            async function checkStockSignal(stock) {
                console.log(`Checking ${stock.fullSymbol}...`);
                const card = document.getElementById(`card-${stock.id}`);
                const priceText = card ? card.querySelector('[data-status="price"]') : null;
                const currentPrice = (priceText && priceText.textContent !== '--.--') ? priceText.textContent : '--.--';
                
                const stockInWatchlist = watchlist.find(s => s.id === stock.id);
                if (!stockInWatchlist) return; // 削除済み
                
                // [修正] トレンドを初期表示
                const initialTrendText = card ? (card.querySelector('[data-status="trend"]')?.textContent || '--') : '--';
                
                if (!stockInWatchlist.position) {
                         updateCardStatus(stock.id, 'loading', null, currentPrice, initialTrendText); // message: null
                } else {
                        updateCardStatus(stock.id, 'loading', null, currentPrice, initialTrendText); // message: null
                }


                try {
                    const dailyData = await fetchApi(stock.fullSymbol);

                    const result = dailyData.chart.result[0];
                    const indicators = result.indicators.quote[0];
                    const timestamps = result.timestamp;
                    
                    let chronoPrices = [];
                    let chronoDailyObjects = [];
                    let chronoVolumes = [];
                    // let chronoOpens = []; // [削除]

                    for (let i = 0; i < timestamps.length; i++) {
                        const open = indicators.open[i]; 
                        const close = indicators.close[i];
                        const high = indicators.high[i];
                        const low = indicators.low[i];
                        const volume = indicators.volume[i];

                        chronoPrices.push(typeof close === 'number' ? close : null);
                        chronoVolumes.push(typeof volume === 'number' ? volume : null);
                        // chronoOpens.push(typeof open === 'number' ? open : null); // [削除]
                        
                        chronoDailyObjects.push({
                            open: typeof open === 'number' ? open : null, 
                            high: typeof high === 'number' ? high : null,
                            low: typeof low === 'number' ? low : null,
                            close: typeof close === 'number' ? close : null
                        });
                    }

                    if (chronoPrices.length < 50) {
                        throw new Error(`分析に必要なデータ期間が不足しています ( ${chronoPrices.length} / 50 )。`);
                    }

                    let lastValidData = null;
                    let lastValidTimestamp = null;
                    for (let i = chronoPrices.length - 1; i >= 0; i--) {
                        if (typeof chronoPrices[i] === 'number' && typeof chronoVolumes[i] === 'number') {
                            lastValidData = {
                                close: chronoPrices[i],
                                volume: chronoVolumes[i]
                            };
                            lastValidTimestamp = timestamps[i];
                            break;
                        }
                    }

                    if (lastValidData === null) {
                        throw new Error("有効な最新データが見つかりませんでした。");
                    }
                    
                    const todayKey = new Date(lastValidTimestamp * 1000).toISOString().split('T')[0];
                    const todayClose = lastValidData.close;
                    
                    if (stockInWatchlist.position) {
                         updateCardStatus(stock.id, 'loading', null, todayClose.toFixed(2), initialTrendText);
                    }
                    
                    const macdResult = calculateMACD(chronoPrices);
                    const rsi_today = calculateRSI(chronoPrices);
                    const atr_today = calculateATR(chronoDailyObjects);

                    const volumes_desc = [...chronoVolumes].reverse();
                    const vma20 = calculateSMA(volumes_desc, 20);

                    // [新規] トレンド判定 (5/25 SMA)
                    const sma5Array = calculateSMAArray(chronoPrices, 5);
                    const sma25Array = calculateSMAArray(chronoPrices, 25);
                    
                    // 最新の有効なSMA値を取得
                    const sma5 = sma5Array.filter(v => typeof v === 'number').pop();
                    const sma25 = sma25Array.filter(v => typeof v === 'number').pop();

                    let trendMsg = '--';
                    if (typeof sma5 === 'number' && typeof sma25 === 'number') {
                        if (sma5 > sma25) {
                            trendMsg = '上昇';
                        } else if (sma5 < sma25) {
                            trendMsg = '下降';
                        } else {
                            trendMsg = '横ばい';
                        }
                    }
                    
                    if (macdResult === null || rsi_today === null || atr_today === null || vma20 === null) {
                        console.warn("Calculation results:", { macdResult, rsi_today, atr_today, vma20 });
                        throw new Error("テクニカル指標の計算に失敗しました。データ不足の可能性があります。");
                    }

                    const todayVolume = lastValidData.volume;
                    
                    const macd_today = macdResult.today.macd;
                    const signal_today = macdResult.today.signal;
                    const hist_today = macdResult.today.hist;
                    
                    const macd_yesterday = macdResult.yesterday.macd;
                    const signal_yesterday = macdResult.yesterday.signal;

                    const isLongCross = (macd_yesterday < signal_yesterday) && (macd_today > signal_today);
                    const isHistPositive = hist_today > 0;
                    const isShortCross = (macd_yesterday > signal_yesterday) && (macd_today < signal_today);
                    const isHistNegative = hist_today < 0;
                    
                    // [変更] 出来高の条件を 1.5倍 と 2.0倍 で事前計算
                    let isVolumeHigh_1_5 = false;
                    let isVolumeHigh_2_0 = false;
                    if (vma20 !== null) {
                        isVolumeHigh_1_5 = todayVolume > (vma20 * 1.5);
                        isVolumeHigh_2_0 = todayVolume > (vma20 * 2.0);
                    }
                    
                    const isRsiInRange = rsi_today > 35 && rsi_today < 65;


                    // --- ロジック分岐 ---

                    // --- 1. ポジション保有中の場合、決済シグナルをチェック ---
                    if (stockInWatchlist.position) {
                        const { type, entryPrice, stopLoss, profitTarget } = stockInWatchlist.position;
                        let exitSignal = null;

                        if (type === 'LONG') {
                            if (todayClose < stopLoss) {
                                exitSignal = { type: 'STOP_LOSS_LONG', message: `損切り (L): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                            } else if (todayClose > profitTarget) {
                                exitSignal = { type: 'PROFIT_TAKE_LONG', message: `利確 (L): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                            } else if (isShortCross && isHistNegative) { // 反対シグナル
                                exitSignal = { type: 'EXIT_LONG', message: `反対シグナル (L): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                            }
                        } else if (type === 'SHORT') {
                            if (todayClose > stopLoss) {
                                exitSignal = { type: 'STOP_LOSS_SHORT', message: `損切り (S): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                            } else if (todayClose < profitTarget) {
                                exitSignal = { type: 'PROFIT_TAKE_SHORT', message: `利確 (S): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                            } else if (isLongCross && isHistPositive) { // 反対シグナル
                                exitSignal = { type: 'EXIT_SHORT', message: `反対シグナル (S): ${stock.fullSymbol} @ ${todayClose.toFixed(2)}` };
                            }
                        }

                        if (exitSignal) {
                            
                            stockInWatchlist.position = null; // ポジションリセット
                            saveWatchlist();

                            const exitPriceMsg = `決済価格: ${todayClose.toFixed(2)}`;
                            switch (exitSignal.type) {
                                case 'STOP_LOSS_LONG':
                                case 'STOP_LOSS_SHORT':
                                    updateCardStatus(stock.id, 'stop-loss', exitPriceMsg, todayClose.toFixed(2), trendMsg);
                                    break;
                                case 'PROFIT_TAKE_LONG':
                                case 'PROFIT_TAKE_SHORT':
                                    updateCardStatus(stock.id, 'profit-take', exitPriceMsg, todayClose.toFixed(2), trendMsg);
                                    break;
                                case 'EXIT_LONG':
                                case 'EXIT_SHORT':
                                    updateCardStatus(stock.id, 'exit', `反対シグナル決済 @ ${todayClose.toFixed(2)}`, todayClose.toFixed(2), trendMsg);
                                    break;
                            }
                            
                            return; // 決済したので終了
                        } else {
                            // 保有中ステータスを更新
                            const sl = stockInWatchlist.position.stopLoss.toFixed(2);
                            const pt = stockInWatchlist.position.profitTarget.toFixed(2);
                            if (stockInWatchlist.position.type === 'LONG') {
                                updateCardStatus(stock.id, 'holding-long', `損切: ${sl} / 利確: ${pt}`, todayClose.toFixed(2), trendMsg);
                            } else {
                                updateCardStatus(stock.id, 'holding-short', `損切: ${sl} / 利確: ${pt}`, todayClose.toFixed(2), trendMsg);
                            }
                            return; // 保有継続
                        } 
                        
                    } // if (stockInWatchlist.position) ブロック終了
                    
                    // --- 2. ポジション非保有の場合、新規エントリーシグナルをチェック ---
                    if (stockInWatchlist.position === null) {
                        
                        // [新規] シグナル強度 (1-5段階) を計算
                        let strength = 0;
                        const isLongSignalBase = isLongCross && isHistPositive;
                        const isShortSignalBase = isShortCross && isHistNegative;

                        if (isLongSignalBase) {
                            strength = 1; // 1. ベース (クロス + ヒスト)
                            if (isRsiInRange) strength += 1; // 2. RSI
                            if (trendMsg === '上昇') strength += 1; // 3. トレンド
                            
                            // 4. 出来高 (2段階)
                            if (isVolumeHigh_2_0) strength += 2;
                            else if (isVolumeHigh_1_5) strength += 1;
                            
                        } else if (isShortSignalBase) {
                            strength = 1; // 1. ベース (クロス + ヒスト)
                            if (isRsiInRange) strength += 1; // 2. RSI
                            if (trendMsg === '下降') strength += 1; // 3. トレンド
                            
                            // 4. 出来高 (2段階)
                            if (isVolumeHigh_2_0) strength += 2;
                            else if (isVolumeHigh_1_5) strength += 1;
                        }
                        
                        // [変更] strength が 1 以上 (ベースシグナル発生) の場合、エントリー
                        if (strength > 0) {
                            
                            if (isLongSignalBase) {
                                const stopLoss = (todayClose - (atr_today * 2));
                                const profitTarget = (todayClose + (atr_today * 2)); // 1:1 R/R
                                
                                stockInWatchlist.position = { type: 'LONG', entryPrice: todayClose, stopLoss: stopLoss, profitTarget: profitTarget };
                                saveWatchlist();

                                // [変更] strength を updateCardStatus に渡す
                                updateCardStatus(stock.id, 'signal-long', null, todayClose.toFixed(2), trendMsg, strength, stopLoss, profitTarget);
                                return;

                            } else if (isShortSignalBase) {
                                const stopLoss = (todayClose + (atr_today * 2));
                                const profitTarget = (todayClose - (atr_today * 2)); // 1:1 R/R
                                
                                stockInWatchlist.position = { type: 'SHORT', entryPrice: todayClose, stopLoss: stopLoss, profitTarget: profitTarget };
                                saveWatchlist();
                        
                                // [変更] strength を updateCardStatus に渡す
                                updateCardStatus(stock.id, 'signal-short', null, todayClose.toFixed(2), trendMsg, strength, stopLoss, profitTarget);
                                return;
                            }
                        }
                    }
                    
                    console.log(`No signal for ${stock.fullSymbol} on ${todayKey}.`);
                    // [変更] strength (0) を渡す
                    updateCardStatus(stock.id, 'idle', 'シグナルなし', todayClose.toFixed(2), trendMsg, 0);

                } catch (error) {
                    console.error(`Error checking ${stock.fullSymbol}:`, error);
                    // [変更] strength (0) を渡す
                    updateCardStatus(stock.id, 'error', `エラー: ${error.message}`, currentPrice, '--', 0); // エラー時はトレンドもリセット
                }
            }

            // --- UI更新 ---

            /**
             * ウォッチリストを再描画
             */
            function renderWatchlist() {
                watchlistContainer.innerHTML = '';
                if (watchlist.length === 0) {
                    watchlistContainer.innerHTML = '<p class="text-gray-500 col-span-full no-stocks-message">監視中の銘柄はありません。</p>';
                    return;
                }

                watchlist.forEach(stock => {
                    renderSingleStock(stock); // 個別描画関数を呼ぶ
                });
            }

            /**
             * [新規] 単一の銘柄カードを描画してDOMに追加
             */
            function renderSingleStock(stock) {
                // 「銘柄なし」メッセージがあれば削除
                const noStocksMessage = watchlistContainer.querySelector('.no-stocks-message');
                if (noStocksMessage) {
                    noStocksMessage.remove();
                }

                const card = document.createElement('div');
                card.id = `card-${stock.id}`;
                card.className = 'bg-white p-6 rounded-lg shadow-md transition-all';
                card.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <!-- [修正] leading-9 -> leading-7 -->
                            <h3 class="text-lg font-bold leading-7">${stock.symbol} <span class="text-sm font-normal text-gray-500">(${stock.market})</span></h3>
                            <!-- [修正] mt-3 leading-9 -> mt-2 leading-7 -->
                            <p class="text-2xl font-bold mt-2 leading-7" data-status="price">--.--</p>
                            <!-- [修正] mt-2 leading-9 -> mt-1 leading-7 -->
                            <p class="text-md font-semibold mt-1 leading-7" data-status="trend">--</p>
                            <!-- [新規] シグナル強度 (★) 用の行 -->
                            <p class="text-lg font-bold mt-2 leading-7" data-status="strength"> </p>
                            <!-- [修正] mt-3 leading-9 -> mt-1 leading-7 -->
                            <p class="text-md font-semibold mt-1 leading-7" data-status="signal">--</p>
                        </div>
                        <div class="flex flex-col items-end space-y-2">
                             <div class="loader w-5 h-5 rounded-full border-4 border-gray-200 hidden" data-status="loader"></div>
                             <button data-action="remove" data-id="${stock.id}" class="text-gray-400 hover:text-red-500 transition-colors mt-auto">
                                 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                             </button>
                        </div>
                    </div>
                    <!-- [追加] 個別更新ゲージ -->
                    <!-- [変更] mt-4 から mt-6 に変更 -->
                    <div class="w-full bg-gray-200 rounded-full h-1 mt-6 overflow-hidden">
                        <div data-status="progress-bar" class="bg-blue-600 h-1 rounded-full" style="width: 0%; transition: width 0.1s linear;"></div>
                    </div>
                `;
                watchlistContainer.appendChild(card);
                
                // [修正] トレンド引数(null)を追加
                if (stock.position) {
                    const sl = stock.position.stopLoss.toFixed(2);
                    const pt = stock.position.profitTarget.toFixed(2);
                    if (stock.position.type === 'LONG') {
                         updateCardStatus(stock.id, 'holding-long', `損切: ${sl} / 利確: ${pt}`, stock.position.entryPrice.toFixed(2), '--');
                    } else {
                         updateCardStatus(stock.id, 'holding-short', `損切: ${sl} / 利確: ${pt}`, stock.position.entryPrice.toFixed(2), '--');
                    }
                }
            }
            
            /**
             * 銘柄カードのステータスを更新
             */
            // [修正] 引数を (stockId, statusType, message, price, trend, strength, stopLoss, profitTarget) に変更
            function updateCardStatus(stockId, statusType, message, price, trend, strength = 0, stopLoss = 0, profitTarget = 0) { 
                const card = document.getElementById(`card-${stockId}`);
                if (!card) return;

                // [削除] statusText を削除
                const priceText = card.querySelector('[data-status="price"]');
                const signalText = card.querySelector('[data-status="signal"]');
                const trendText = card.querySelector('[data-status="trend"]'); // [新規]
                const strengthText = card.querySelector('[data-status="strength"]'); // [新規]
                // [削除] patternText を削除
                const loader = card.querySelector('[data-status="loader"]');
                
                // [削除] statusText のクラス名設定を削除
                // [変更] mt-2 から mt-3 に変更
                // [変更] line-height (leading-9) をベースクラスに追加
                // [修正] mt-3 leading-9 -> mt-1 leading-7
                signalText.className = 'text-md font-semibold mt-1 leading-7';
                // [変更] mt-1 から mt-2 に変更
                // [変更] line-height (leading-9) をベースクラスに追加
                // [修正] mt-2 leading-9 -> mt-1 leading-7
                trendText.className = 'text-md font-semibold mt-1 leading-7'; // [新規]
                loader.classList.add('hidden');
                card.classList.remove('bg-green-50', 'bg-red-50', 'bg-yellow-50', 'bg-blue-50', 'border-green-400', 'border-red-400', 'border-yellow-400', 'bg-gray-100', 'border-gray-400', 'border-blue-400'); 
                card.style.borderWidth = "0px";
                
                if (price !== '--.--') {
                    priceText.textContent = price;
                }

                // [新規] トレンド表示の更新
                if (trendText) {
                    trendText.textContent = trend || '--';
                    if (trend === '上昇') {
                        // [変更] mt-1 から mt-2 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-2 leading-9 -> mt-1 leading-7
                        trendText.className = 'text-md font-semibold mt-1 leading-7 text-green-600';
                    } else if (trend === '下降') {
                        // [変更] mt-1 から mt-2 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-2 leading-9 -> mt-1 leading-7
                        trendText.className = 'text-md font-semibold mt-1 leading-7 text-red-600';
                    } else {
                        // [変更] mt-1 から mt-2 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-2 leading-9 -> mt-1 leading-7
                        trendText.className = 'text-md font-semibold mt-1 leading-7 text-gray-500';
                    }
                }


                // [新規] シグナル強度の表示 (★)
                strengthText.className = 'text-lg font-bold mt-2 leading-7';
                strengthText.textContent = ' '; // デフォルトは空
                if (strength > 0) {
                    const stars = '★'.repeat(strength) + '☆'.repeat(5 - strength);
                    strengthText.textContent = stars;
                    if (statusType === 'signal-long') {
                        strengthText.className = 'text-lg font-bold mt-2 leading-7 text-green-700';
                    } else if (statusType === 'signal-short') {
                        strengthText.className = 'text-lg font-bold mt-2 leading-7 text-red-700';
                    }
                }


                switch (statusType) {
                    case 'loading':
                        // [修正] statusText.textContent を削除
                        signalText.textContent = '更新中...'; // シグナル欄に更新中を表示
                        // [変更] mt-2 から mt-3 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-3 leading-9 -> mt-1 leading-7
                        signalText.className = 'text-md font-semibold mt-1 leading-7 text-blue-600';
                        loader.classList.remove('hidden');
                        break;
                    case 'idle':
                        // [修正] statusText.textContent を削除
                        signalText.textContent = message; // 'シグナルなし'
                        // [変更] mt-2 から mt-3 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-3 leading-9 -> mt-1 leading-7
                        signalText.className = 'text-md font-semibold mt-1 leading-7 text-gray-600';
                        break;
                    case 'signal-long': 
                        // [修正] メッセージをSL/PTから生成
                        signalText.textContent = `買い (損切: ${stopLoss.toFixed(2)} / 利確: ${profitTarget.toFixed(2)})`;
                        // [変更] mt-2 から mt-3 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-3 leading-9 -> mt-1 leading-7
                        signalText.className = 'text-md font-semibold mt-1 leading-7 text-green-700';
                        card.classList.add('bg-green-50', 'border-green-400');
                        card.style.borderWidth = "2px";
                        break;
                    case 'signal-short': 
                        // [修正] メッセージをSL/PTから生成
                        signalText.textContent = `売り (損切: ${stopLoss.toFixed(2)} / 利確: ${profitTarget.toFixed(2)})`;
                        // [変更] mt-2 から mt-3 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-3 leading-9 -> mt-1 leading-7
                        signalText.className = 'text-md font-semibold mt-1 leading-7 text-red-700';
                        card.classList.add('bg-red-50', 'border-red-400');
                        card.style.borderWidth = "2px";
                        break;
                    case 'holding-long': 
                        // [修正] statusText.textContent を削除
                        signalText.textContent = message; // '損切: ...'
                        // [変更] mt-2 から mt-3 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-3 leading-9 -> mt-1 leading-7
                        signalText.className = 'text-md font-semibold mt-1 leading-7 text-green-700';
                        card.classList.add('bg-green-50'); 
                        break;
                    case 'holding-short': 
                        // [修正] statusText.textContent を削除
                        signalText.textContent = message; // '損切: ...'
                        // [変更] mt-2 から mt-3 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-3 leading-9 -> mt-1 leading-7
                        signalText.className = 'text-md font-semibold mt-1 leading-7 text-red-700';
                        card.classList.add('bg-red-50');
                        break;
                    case 'error':
                        // [修正] statusText.textContent を削除
                        signalText.textContent = message; // 'エラー: ...'
                        // [変更] mt-2 から mt-3 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-3 leading-9 -> mt-1 leading-7
                        signalText.className = 'text-md font-semibold mt-1 leading-7 text-yellow-800';
                        card.classList.add('bg-yellow-50', 'border-yellow-400');
                        card.style.borderWidth = "2px";
                        break;
                    // --- 決済シグナル ---
                    case 'profit-take':
                        // [修正] statusText.textContent を削除
                        signalText.textContent = message; // '決済価格: ...'
                        // [変更] mt-2 から mt-3 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-3 leading-9 -> mt-1 leading-7
                        signalText.className = 'text-md font-semibold mt-1 leading-7 text-blue-700';
                        card.classList.add('bg-blue-50', 'border-blue-400');
                        card.style.borderWidth = "2px";
                        break;
                    case 'stop-loss':
                        // [修正] statusText.textContent を削除
                        signalText.textContent = message; // '決済価格: ...'
                        // [変更] mt-2 から mt-3 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-3 leading-9 -> mt-1 leading-7
                        signalText.className = 'text-md font-semibold mt-1 leading-7 text-yellow-800'; 
                        card.classList.add('bg-yellow-50', 'border-yellow-400');
                        card.style.borderWidth = "2px";
                        break;
                    case 'exit':
                        // [修正] statusText.textContent を削除
                        signalText.textContent = message; // '反対シグナル決済...'
                        // [変更] mt-2 から mt-3 に変更
                        // [変更] line-height (leading-9) を追加
                        // [修正] mt-3 leading-9 -> mt-1 leading-7
                        signalText.className = 'text-md font-semibold mt-1 leading-7 text-gray-700';
                        card.classList.add('bg-gray-100', 'border-gray-400');
                        card.style.borderWidth = "2px";
                        break;
                    default:
                        // [修正] statusText.textContent を削除
                        signalText.textContent = '--';
                }
            }
            
            // --- 状態管理 (LocalStorage) ---
            function loadWatchlist() {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    const loaded = JSON.parse(stored);
                    watchlist = loaded.map(stock => ({
                        ...stock,
                        position: stock.position || null,
                        timerId: null // [修正] 起動時はtimerIdをnullで初期化
                    }));
                }
            }

            function saveWatchlist() {
                // [修正] timerIdは保存しない
                const savableWatchlist = watchlist.map(stock => ({
                    id: stock.id,
                    symbol: stock.symbol,
                    market: stock.market,
                    fullSymbol: stock.fullSymbol,
                    position: stock.position
                }));
                localStorage.setItem(STORAGE_KEY, JSON.stringify(savableWatchlist));
            }

            // --- [新規] 全件チェックとタイマー開始 ---
            function checkAllSignalsAndStartTimers(isInitialLoad = false) {
                if (watchlist.length === 0) return;

                let delay = 0;
                // API負荷軽減のため、初回ロード時のみ遅延させる
                const delayIncrement = isInitialLoad ? 2000 : 0; // 2秒 (初回ロード時) / 0秒 (追加時)

                console.log(`checkAllSignalsAndStartTimers called (isInitialLoad: ${isInitialLoad})`);

                watchlist.forEach(stock => {
                    // 既存のタイマーをクリア (renderWatchlistでDOMが再生成されるため必須)
                    if (stock.timerId) {
                        clearInterval(stock.timerId);
                        stock.timerId = null;
                    }

                    const exec = () => {
                        checkStockSignal(stock); // データチェック
                        startStockTimer(stock); // ゲージタイマースタート
                    };

                    if (delayIncrement > 0) {
                         setTimeout(exec, delay);
                         delay += delayIncrement;
                    } else {
                        // 追加時は即時実行
                        exec();
                    }
                });

                if (isInitialLoad && watchlist.length > 5) {
                    console.log(`全${watchlist.length}銘柄の更新を開始します (2秒間隔)。`);
                }
            }


            // --- イベントリスナー ---
            addStockForm.addEventListener('submit', (e) => {
                e.preventDefault();
                formError.textContent = '';
                
                const market = marketSelect.value;
                let symbol = symbolInput.value.trim().toUpperCase();

                if (!symbol) {
                    formError.textContent = '銘柄コードを入力してください。';
                    return;
                }
                
                let fullSymbol = symbol;
                if (market === 'JP') {
                    if (!symbol.endsWith('.T')) {
                        fullSymbol = `${symbol}.T`;
                    }
                }
                
                const id = `${market}-${fullSymbol}`;

                if (watchlist.some(stock => stock.id === id)) {
                    formError.textContent = 'この銘柄は既に追加されています。';
                    return;
                }

                // [修正] timerId: null を追加
                const newStock = { id, symbol, market, fullSymbol, position: null, timerId: null }; 
                watchlist.push(newStock);
                
                saveWatchlist();

                // [修正] 既存のタイマーをすべて停止 (renderWatchlistの前に実行)
                /* (削除)
                watchlist.forEach(stock => {
                    if (stock.timerId) {
                        clearInterval(stock.timerId);
                        stock.timerId = null;
                    }
                });
                */

                // renderWatchlist(); // (削除) これでカードがDOMに追加される
                
                // [修正] 全件のタイマーを（再）スタート (初回ロードフラグなし)
                // これにより、既存の銘柄の価格も再取得され、ゲージもリスタートする
                // checkAllSignalsAndStartTimers(false); (削除)

                // [新規] 単一のカードを描画
                renderSingleStock(newStock); 
                
                // [新規] 新しい銘柄のみシグナルチェックとタイマーを開始
                checkStockSignal(newStock);
                startStockTimer(newStock);

                symbolInput.value = '';
            });

            watchlistContainer.addEventListener('click', (e) => {
                const removeButton = e.target.closest('[data-action="remove"]');
                if (removeButton) {
                    const stockId = removeButton.dataset.id;
                    
                    // [修正] 削除する銘柄のタイマーを停止する
                    const stockToRemove = watchlist.find(stock => stock.id === stockId);
                    if (stockToRemove && stockToRemove.timerId) {
                        clearInterval(stockToRemove.timerId); // タイマー停止
                    }
                    
                    watchlist = watchlist.filter(stock => stock.id !== stockId);
                    saveWatchlist();
                    
                    const card = document.getElementById(`card-${stockId}`);
                    if (card) {
                        card.remove();
                    }
                    
                    if (watchlist.length === 0) {
                        watchlistContainer.innerHTML = '<p class="text-gray-500 col-span-full no-stocks-message">監視中の銘柄はありません。</p>';
                    }
                }
            });
            
            // --- [削除] 自動更新ロジック (グローバル) ---
            // let lastUpdateTime = 0; (削除)
            // function checkAllStocks() (削除)
            // function mainUpdateLoop(timestamp) (削除)


            // --- 初期化 ---
            function init() {
                loadWatchlist(); // watchlist には timerId は保存されていない (nullで初期化される)
                
                renderWatchlist(); // DOMにカードを描画
                
                // [修正] 起動時に全件チェックし、個別のタイマーを開始 (初回ロードフラグを立てる)
                checkAllSignalsAndStartTimers(true); 
                
                // [削除] requestAnimationFrame(mainUpdateLoop);
            }

            init();
        });
    </script>

</body>
</html>